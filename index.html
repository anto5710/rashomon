<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />
        <title>Scroll = Play (Manual Only • Ultra-Smooth)</title>
        <style>
            html,
            body {
                margin: 0;
                background: #0b1020;
                color: #e5e7eb;
                font-family: system-ui, -apple-system, Segoe UI, Roboto,
                    Helvetica, Arial, sans-serif;
            }
            .wrap {
                max-width: 1200px;
                margin: 0 auto;
                font-size: 0;
                line-height: 0;
                will-change: filter; /* for smooth blur */
                transition: filter 80ms linear; /* tiny smoothing on visual blur */
            }
            .wrap img {
                display: block;
                width: 100%;
                height: auto;
                margin: 0;
                border: 0;
            }

            /* minimal hint: blinking down arrow, fades on first interaction */
            .hint {
                position: fixed;
                left: 50%;
                bottom: 24px;
                transform: translateX(-50%);
                z-index: 10;
                font-size: 20px;
                opacity: 0.9;
                user-select: none;
                pointer-events: none;
                animation: blink 1.1s ease-in-out infinite;
            }
            @keyframes blink {
                0%,
                100% {
                    opacity: 0.15;
                }
                50% {
                    opacity: 0.95;
                }
            }
            .hint.hide {
                animation: none;
                opacity: 0;
                transition: opacity 0.35s ease;
            }
        </style>
    </head>
    <body>
        <div id="wrap" class="wrap" aria-label="Timeline images"></div>
        <div id="hint" class="hint" aria-hidden="true">⬇︎</div>

        <script>
            /* ========= CONFIG ========= */
            const STRIP_COUNT = 125,
                STRIP_PREFIX = "pngs/strip",
                STRIP_EXT = "png"; // strip0.png..stripN.png
            const XFADE_MS = 220; // bus fade

            /* Granular (current user values) */
            const GRAIN_MS = 50,
                HOP_MS = 5,
                LOOKAHEAD_MS = 85,
                POLY = 2;
            const MICRO_JITTER_MS = 0.25;
            const RATE_CAP = 2.0;

            /* Control feel */
            const DRAG_SENSITIVITY = 1 / 980,
                RETURN_LAMBDA = 0.12,
                FRICTION_DECAY = 0.0038;

            /* Tone / anti-squeak */
            const WOW_HZ = 0.6,
                WOW_DEPTH = 0.0023,
                FLUT_HZ = 5.5,
                FLUT_DEPTH = 0.0004;
            // softened highs overall (per your request to minimize the high-pitch on stop)
            const LP_MIN = 1800,
                LP_MAX = 12000;

            /* Idle behavior */
            const IDLE_HOLD_MS = 650,
                RATE_EPS = 0.02;

            /* ========= STRIPS / SCROLL MAPPING ========= */
            const wrap = document.getElementById("wrap"),
                strips = [];
            for (let j = 0; j <= STRIP_COUNT; j++) {
                const im = new Image();
                const i = Math.floor(j+2*Math.random())%5;
                im.alt = `strip ${i}`;
                im.decoding = "sync";
                im.loading = "eager";
                im.src = `${STRIP_PREFIX}${i}.${STRIP_EXT}`;
                wrap.appendChild(im);
                strips.push(im);
            }
            let mappingReady = false,
                startY = 0,
                endY = 1;
            function recomputeMapping(lock = true) {
                if (!strips.length) return;
                const p =
                    lock && mappingReady
                        ? (scrollY - startY) / (endY - startY)
                        : null;
                const first = strips[0],
                    last = strips[strips.length - 1];
                startY = first.offsetTop;
                endY = Math.max(
                    startY + 1,
                    last.offsetTop + last.offsetHeight - innerHeight
                );
                mappingReady = true;
                if (p != null && isFinite(p)) {
                    const y =
                        startY + Math.min(1, Math.max(0, p)) * (endY - startY);
                    if (Math.abs(scrollY - y) > 0.5) scrollTo(0, y);
                }
            }
            addEventListener("resize", () => recomputeMapping(true), {
                passive: true,
            });
            addEventListener(
                "load",
                () => {
                    if ("scrollRestoration" in history)
                        history.scrollRestoration = "manual";
                    scrollTo(0, 0);
                    recomputeMapping(false);
                    setTimeout(() => recomputeMapping(true), 220);
                },
                { once: true }
            );
            const yFromTime = (t, d) =>
                !mappingReady || !d
                    ? startY
                    : startY +
                      Math.min(1, Math.max(0, t / d)) * (endY - startY);
            const timeFromY = (y, d) =>
                !mappingReady || !d
                    ? 0
                    : Math.min(
                          d,
                          Math.max(0, ((y - startY) / (endY - startY)) * d)
                      );

            /* ========= WebAudio (manual DJ only) ========= */
            const ACtx = window.AudioContext || window.webkitAudioContext;
            const ctx = new ACtx({ latencyHint: "interactive" });
            const main = ctx.createGain();
            main.connect(ctx.destination);
            const djGain = ctx.createGain();
            djGain.gain.value = 0;
            djGain.connect(main);

            // Tone chain
            const djLowShelf = ctx.createBiquadFilter();
            djLowShelf.type = "lowshelf";
            djLowShelf.frequency.value = 160;
            djLowShelf.gain.value = 3.2;
            const djHighShelf = ctx.createBiquadFilter();
            djHighShelf.type = "highshelf";
            djHighShelf.frequency.value = 5200;
            djHighShelf.gain.value = -1.2;
            const djLP = ctx.createBiquadFilter();
            djLP.type = "lowpass";
            djLP.frequency.value = 12000;
            djLP.Q.value = 0.6;
            const djComp = ctx.createDynamicsCompressor();
            djComp.threshold.value = -20;
            djComp.knee.value = 10;
            djComp.ratio.value = 2.2;
            djComp.attack.value = 0.004;
            djComp.release.value = 0.12;
            const djMakeup = ctx.createGain();
            djMakeup.gain.value = 1.26;

            djLowShelf.connect(djHighShelf);
            djHighShelf.connect(djLP);
            djLP.connect(djComp);
            djComp.connect(djMakeup);
            djMakeup.connect(djGain);

            /* Raised-cosine window */
            function hannCurve(n) {
                const a = new Float32Array(n);
                for (let i = 0; i < n; i++)
                    a[i] = 0.5 - 0.5 * Math.cos((2 * Math.PI * i) / (n - 1));
                let p = 0;
                for (let i = 0; i < n; i++) p = Math.max(p, a[i]);
                for (let i = 0; i < n; i++) a[i] /= p;
                return a;
            }
            const ENV_SAMPLES = 128,
                HANN_ENV = hannCurve(ENV_SAMPLES);

            /* Decode audio buffer */
            let buffer = null,
                bufferRev = null,
                duration = 0,
                waReady = false;
            function makeReversed(b) {
                const r = ctx.createBuffer(
                    b.numberOfChannels,
                    b.length,
                    b.sampleRate
                );
                for (let c = 0; c < b.numberOfChannels; c++) {
                    const s = b.getChannelData(c),
                        d = r.getChannelData(c);
                    for (let i = 0, j = s.length - 1; i < s.length; i++, j--)
                        d[i] = s[j];
                }
                return r;
            }
            (async () => {
                try {
                    const ab = await (
                        await fetch("track.mp3", { cache: "no-store" })
                    ).arrayBuffer();
                    buffer = await ctx.decodeAudioData(ab);
                    bufferRev = makeReversed(buffer);
                    duration = buffer.duration || 0;
                    waReady = true;
                    startScheduler();
                } catch (e) {
                    console.error("decode failed", e);
                }
            })();

            /* ========= Engine / Scheduler ========= */
            const grainSec = GRAIN_MS / 1000,
                hopSec = HOP_MS / 1000,
                jitterMax = MICRO_JITTER_MS / 1000;
            let scheduler = null,
                lastSch = 0;
            let enginePos = 0,
                platterRate = 0.0,
                rateTarget = 0.0;
            let lastUserTs = 0,
                hinted = true;

            const clamp = (v, a, b) => Math.min(Math.max(v, a), b);
            function ramp(node, to, ms) {
                const n = ctx.currentTime,
                    t = Math.max(0.001, ms / 1000);
                node.gain.cancelScheduledValues(n);
                node.gain.setValueAtTime(node.gain.value, n);
                node.gain.linearRampToValueAtTime(to, n + t);
            }

            function scheduleGrain(buf, startClock, offset, rate) {
                const src = ctx.createBufferSource();
                src.buffer = buf;
                src.playbackRate.value = rate;
                const g = ctx.createGain();
                g.gain.setValueCurveAtTime(HANN_ENV, startClock, grainSec);
                src.connect(g);
                g.connect(djLowShelf);
                src.start(startClock, offset, grainSec);
                src.stop(startClock + grainSec);
            }

            function startScheduler() {
                if (scheduler || !waReady) return;
                lastSch = ctx.currentTime;
                scheduler = setInterval(() => {
                    if (!waReady || !mappingReady) return;
                    const now = ctx.currentTime,
                        look = LOOKAHEAD_MS / 1000;
                    while (lastSch < now + look) {
                        // activity check
                        const active =
                            performance.now() - lastUserTs < IDLE_HOLD_MS ||
                            Math.abs(platterRate) > RATE_EPS;

                        if (!active) {
                            // gentle brake (reduce highs first, then fade)
                            djLP.frequency.setTargetAtTime(
                                2200,
                                ctx.currentTime,
                                0.03
                            );
                            djHighShelf.gain.setTargetAtTime(
                                -6.0,
                                ctx.currentTime,
                                0.03
                            );
                            ramp(djGain, 0, XFADE_MS);
                            lastSch += hopSec;
                            continue;
                        }

                        // direction & buffer
                        const dir = platterRate >= 0 ? +1 : -1;
                        const buf = dir >= 0 ? buffer : bufferRev;

                        // wow / flutter & effective rate
                        const tAudio = lastSch;
                        const wow =
                            WOW_DEPTH * Math.sin(2 * Math.PI * WOW_HZ * tAudio);
                        const fl =
                            FLUT_DEPTH *
                            Math.sin(2 * Math.PI * FLUT_HZ * tAudio);
                        const base = clamp(
                            Math.abs(platterRate),
                            0.45,
                            RATE_CAP
                        );
                        const eff = clamp(
                            base * (1 + wow + fl),
                            0.38,
                            RATE_CAP
                        );

                        // === anti-harsh LP + shelf near stop ===
                        const timeSinceUser = performance.now() - lastUserTs;
                        const nearStop =
                            Math.abs(platterRate) < 0.08 && timeSinceUser > 40;
                        const coastStop =
                            Math.abs(platterRate) < 0.03 && timeSinceUser > 160;
                        const stopAmt = coastStop
                            ? 1
                            : nearStop
                            ? 0.35 +
                              (0.65 * (0.08 - Math.abs(platterRate))) / 0.08
                            : 0; // 0..1

                        // base cutoff darker when fast / reverse
                        let cut = 14500 / (1 + Math.max(0, eff - 1) * 3.4);
                        if (platterRate < 0) cut *= 0.85;

                        // pull highs down smoothly as we stop
                        const targetCut = cut * (1 - 0.75 * stopAmt);
                        djLP.frequency.setTargetAtTime(
                            Math.max(LP_MIN, Math.min(LP_MAX, targetCut)),
                            ctx.currentTime,
                            0.025
                        );

                        // extra high-shelf tame at stop
                        const shelfDb = -1.2 - 4.0 * stopAmt; // to ~-5.2 dB
                        djHighShelf.gain.setTargetAtTime(
                            shelfDb,
                            ctx.currentTime,
                            0.03
                        );

                        // follow scroll mapping
                        const tMap = timeFromY(scrollY, duration);
                        enginePos += (tMap - enginePos) * 0.12;

                        // offset with small safety tail
                        const tail = 0.006;
                        let off =
                            dir >= 0
                                ? enginePos
                                : duration - enginePos - grainSec;
                        off = clamp(off, 0, buf.duration - grainSec - tail);

                        // ensure bus up
                        ramp(djGain, 1, XFADE_MS);

                        // dual-poly grains
                        const startAt =
                            lastSch +
                            0.002 +
                            (Math.random() * 2 - 1) * jitterMax;
                        scheduleGrain(buf, startAt, off, eff);
                        const startAt2 = startAt + hopSec / 2;
                        const off2 = clamp(
                            off + (dir >= 0 ? +1 : -1) * (hopSec / 2) * eff,
                            0,
                            buf.duration - grainSec - tail
                        );
                        scheduleGrain(buf, startAt2, off2, eff);

                        // advance engine
                        enginePos = clamp(
                            enginePos + (dir >= 0 ? +1 : -1) * hopSec * eff,
                            0,
                            duration
                        );
                        lastSch = startAt + hopSec;
                    }
                }, Math.max(5, HOP_MS / 2));
            }

            /* ========= Input (manual only) ========= */
            async function unlock() {
                try {
                    if (ctx.state !== "running") await ctx.resume();
                } catch {}
            }
            function onUser(e) {
                if (e && e.isTrusted === false) return;
                unlock();
                lastUserTs = performance.now();
                if (hinted) {
                    hinted = false;
                    document.getElementById("hint").classList.add("hide");
                }
            }
            [
                "wheel",
                "touchstart",
                "touchmove",
                "pointerdown",
                "keydown",
                "mousedown",
            ].forEach((evt) => {
                addEventListener(evt, onUser, { passive: true });
            });

            /* ========= Frame loop (scroll → platterRate) + visual blur ========= */
            let lastT = performance.now(),
                lastY = scrollY;
            function loop() {
                const now = performance.now(),
                    dt = Math.max(1, now - lastT),
                    dy = scrollY - lastY;
                lastT = now;
                lastY = scrollY;

                if (mappingReady) {
                    const pxps = (dy * 1000) / dt; // pixels/sec
                    const torque = pxps * DRAG_SENSITIVITY;
                    rateTarget += torque;
                    if (Math.abs(pxps) < 1.5)
                        rateTarget += (0 - rateTarget) * RETURN_LAMBDA;
                    rateTarget += (0 - rateTarget) * FRICTION_DECAY;

                    platterRate += (rateTarget - platterRate) * 0.25;
                    platterRate = clamp(platterRate, -RATE_CAP, RATE_CAP);

                    // ===== Visual blur based on absolute speed =====
                    // Threshold so small jiggles don't blur; scale up to ~10px at very fast scrubs
                    const speed = Math.abs(platterRate);
                    const blurPx = Math.max(0, (speed - 0.9) * 1.4); // starts blurring above ~0.6×
                    wrap.style.filter = `blur(${Math.min(10, blurPx).toFixed(
                        2
                    )}px)`;
                }

                requestAnimationFrame(loop);
            }
            requestAnimationFrame(loop);
        </script>
    </body>
</html>
