<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />
        <title>↓</title>
        <style>
            html,
            body {
                margin: 0;
                background: #0b1020;
                color: #e5e7eb;
                font-family: system-ui, -apple-system, Segoe UI, Roboto,
                    Helvetica, Arial, sans-serif;
            }
            .wrap {
                max-width: 1200px;
                margin: 0 auto;
                font-size: 0;
                line-height: 0;
                will-change: filter, transform;
                transition: transform 60ms linear;
                filter: url(#motionBlur);
            }
            /* Each frame reserves height via aspect-ratio (no image needed yet) */
            .frame {
                position: relative;
                width: 100%;
            }
            .base,
            .overlay {
                position: absolute;
                inset: 0;
                display: block;
                width: 100%;
                height: 100%;
                object-fit: cover;
                margin: 0;
                border: 0;
            }
            .overlay {
                pointer-events: none;
            }

            /* Loading overlay */
            .loading {
                position: fixed;
                inset: 0;
                display: grid;
                place-items: center;
                background: #0b1020;
                z-index: 9999;
                transition: opacity 0.35s ease;
            }
            .loading.hide {
                opacity: 0;
                pointer-events: none;
            }
            .dots {
                display: inline-flex;
                gap: 6px;
                align-items: center;
                color: #cbd5e1;
                font-size: 0;
            }
            .dot {
                width: 8px;
                height: 8px;
                border-radius: 50%;
                background: currentColor;
                opacity: 0.25;
                animation: bounce 1.1s infinite ease-in-out;
            }
            .dot:nth-child(2) {
                animation-delay: 0.12s;
            }
            .dot:nth-child(3) {
                animation-delay: 0.24s;
            }
            @keyframes bounce {
                0%,
                80%,
                100% {
                    transform: translateY(0);
                    opacity: 0.25;
                }
                40% {
                    transform: translateY(-6px);
                    opacity: 0.95;
                }
            }

            /* Hint */
            .hint {
                position: fixed;
                left: 50%;
                bottom: 20px;
                transform: translateX(-50%);
                z-index: 10;
                font-size: 14px;
                opacity: 0.9;
                user-select: none;
                pointer-events: none;
                animation: blink 1.1s ease-in-out infinite;
            }
            @keyframes blink {
                0%,
                100% {
                    opacity: 0.15;
                }
                50% {
                    opacity: 0.95;
                }
            }
            .hint.hide {
                animation: none;
                opacity: 0;
                transition: opacity 0.35s ease;
            }

            @media (max-width: 600px) {
                .hint {
                    font-size: 12px;
                    bottom: 16px;
                }
                .dot {
                    width: 7px;
                    height: 7px;
                }
                .dots {
                    gap: 5px;
                }
            }
        </style>
    </head>
    <body>
        <!-- SVG directional blur -->
        <svg width="0" height="0" style="position: absolute">
            <filter
                id="motionBlur"
                x="-50%"
                y="-50%"
                width="200%"
                height="200%"
            >
                <feGaussianBlur in="SourceGraphic" stdDeviation="0 0" />
            </filter>
        </svg>

        <div
            id="loader"
            class="loading"
            aria-live="polite"
            aria-label="Loading"
        >
            <div class="dots" aria-hidden="true">
                <div class="dot"></div>
                <div class="dot"></div>
                <div class="dot"></div>
            </div>
        </div>

        <div id="wrap" class="wrap" aria-label="Timeline images"></div>
        <div id="hint" class="hint hide" aria-hidden="true">⬇︎</div>

        <script>
            /* ================== CONFIG ================== */
            const STRIP_COUNT = 354;
            const STRIP_PREFIX = "strips/strip";
            const STRIP_EXT = "jpeg";
            const USE_MOD = true; // true: strip{ i % MOD_BASE }
            const MOD_BASE = 6;

            // Overlays per frame (transparent)
            const OVERLAY_LAYERS = 5;
            const OVERLAY_USE_MOD = true; // true: comments{ i % OVERLAY_MOD_BASE }_L{n}
            const OVERLAY_MOD_BASE = 6;
            const OVERLAY_TEMPLATE = (idx, layer) =>
                `comments/comments${idx}_L${layer}.png`;

            const AUDIO_URL = "tracks/nymetro.mp3";

            /* Audio engine params (same feel as before) */
            const XFADE_MS = 260,
                GRAIN_MS = 50,
                HOP_MS = 5,
                LOOKAHEAD_MS = 85,
                MICRO_JITTER_MS = 0.25,
                RATE_CAP = 2.0;
            const DRAG_SENSITIVITY = 1 / 980,
                RETURN_LAMBDA = 0.12,
                FRICTION_DECAY = 0.0038;
            const WOW_HZ = 0.6,
                WOW_DEPTH = 0.0023,
                FLUT_HZ = 5.5,
                FLUT_DEPTH = 0.0004;
            const LP_MIN = 1500,
                LP_MAX = 11000;
            const IDLE_HOLD_MS = 650,
                RATE_EPS = 0.02;
            const BLUR_TARGET_GAIN = 1.3,
                BLUR_MAX = 14,
                BLUR_THRESHOLD = 0.7,
                BLUR_SMOOTH = 0.5;
            const SHIFT_GAIN = 5,
                SHIFT_MAX = 6,
                SHIFT_SMOOTH = 0.6;

            /* ================== DOM BUILD (NO SRC YET) ================== */
            const wrap = document.getElementById("wrap");
            const frames = new Array(STRIP_COUNT + 1);
            const bases = new Array(STRIP_COUNT + 1);
            const ovMap = new Array(STRIP_COUNT + 1); // array of arrays

            for (let i = 0; i <= STRIP_COUNT; i++) {
                const frame = document.createElement("div");
                frame.className = "frame";
                // Reserve size via aspect-ratio later; for now put a default
                frame.style.aspectRatio = "16 / 9"; // temporary; will be corrected after first base loads

                const base = new Image();
                base.className = "base";
                // no src yet – we’ll lazy assign

                frame.appendChild(base);

                const ovs = [];
                for (let L = 0; L < OVERLAY_LAYERS; L++) {
                    const ov = new Image();
                    ov.className = "overlay";
                    // no src yet – lazy
                    ov.style.display = "none";
                    ov.onerror = () => {
                        ov.style.display = "none";
                        ov.removeAttribute("src");
                    };
                    frame.appendChild(ov);
                    ovs.push(ov);
                }

                wrap.appendChild(frame);
                frames[i] = frame;
                bases[i] = base;
                ovMap[i] = ovs;
            }

            /* ================== SIZE CALIBRATION (ONLY 1 BASE LOAD) ================== */
            let mappingReady = false,
                startY = 0,
                endY = 1;

            async function calibrateAspect() {
                // Load only strip0 (or modulo 0) to get true aspect ratio
                const idx0 = USE_MOD ? 0 : 0;
                const probe = new Image();
                probe.decoding = "sync";
                probe.loading = "eager";
                probe.src = `${STRIP_PREFIX}${idx0}.${STRIP_EXT}`;
                await (probe.decode
                    ? probe.decode().catch(() => {})
                    : Promise.resolve());
                const w = probe.naturalWidth || 1920;
                const h = probe.naturalHeight || 1080;
                const ratio = `${w} / ${h}`;

                // Apply correct aspect to all frames (gives correct heights immediately)
                frames.forEach((f) => {
                    f.style.aspectRatio = ratio;
                });

                // Also assign src to the very first visible base so the top frame paints quickly
                bases[0].src = probe.src;
                try {
                    if (bases[0].decode) await bases[0].decode();
                } catch {}
            }

            function recomputeMapping(lock = true) {
                const p =
                    lock && mappingReady
                        ? (scrollY - startY) / (endY - startY)
                        : null;
                const first = frames[0];
                const last = frames[frames.length - 1];
                startY = first.offsetTop;
                endY = Math.max(
                    startY + 1,
                    last.offsetTop + last.offsetHeight - innerHeight
                );
                mappingReady = true;
                if (p != null && isFinite(p)) {
                    const y =
                        startY + Math.min(1, Math.max(0, p)) * (endY - startY);
                    if (Math.abs(scrollY - y) > 0.5) scrollTo(0, y);
                }
            }

            addEventListener("resize", () => recomputeMapping(true), {
                passive: true,
            });

            /* ================== LAZY LOAD BASES & MULTI-OVERLAYS ================== */
            function baseSrc(i) {
                const idx = USE_MOD ? i % MOD_BASE : i;
                return `${STRIP_PREFIX}${idx}.${STRIP_EXT}`;
            }
            function overlaySrc(i, L) {
                const idx = OVERLAY_USE_MOD ? i % OVERLAY_MOD_BASE : i;
                return OVERLAY_TEMPLATE(idx, L);
            }

            async function ensureBaseLoaded(i) {
                const img = bases[i];
                if (!img || img.getAttribute("src")) return;
                img.src = baseSrc(i);
                try {
                    if (img.decode) await img.decode();
                } catch {}
            }
            async function ensureOverlaysLoaded(i) {
                const arr = ovMap[i];
                if (!arr) return;
                await Promise.all(
                    arr.map(async (ov, L) => {
                        if (ov.getAttribute("src")) return;
                        const src = overlaySrc(i, L);
                        ov.src = src;
                        try {
                            if (ov.decode) await ov.decode();
                        } catch {}
                        if (ov.naturalWidth > 0) ov.style.display = "";
                    })
                );
            }
            function unloadBase(i) {
                const img = bases[i];
                if (!img) return;
                if (img.getAttribute("src")) img.removeAttribute("src");
            }
            function unloadOverlays(i) {
                const arr = ovMap[i];
                if (!arr) return;
                arr.forEach((ov) => {
                    if (ov.getAttribute("src")) {
                        ov.style.display = "none";
                        ov.removeAttribute("src");
                    }
                });
            }

            const io = new IntersectionObserver(
                (entries) => {
                    entries.forEach((entry) => {
                        // Find which frame index this is
                        const i = frames.indexOf(entry.target);
                        if (i < 0) return;

                        if (entry.isIntersecting) {
                            ensureBaseLoaded(i);
                            ensureOverlaysLoaded(i);
                        } else {
                            // Unload when far away
                            const r = entry.boundingClientRect;
                            const far =
                                r.top > innerHeight * 2 ||
                                r.bottom < -innerHeight * 2;
                            if (far) {
                                unloadOverlays(i);
                                unloadBase(i);
                            }
                        }
                    });
                },
                { root: null, rootMargin: "1000px 0px", threshold: 0 }
            );

            frames.forEach((f) => io.observe(f));

            /* ================== AUDIO: SCROLL-DJ ENGINE ================== */
            const ACtx = window.AudioContext || window.webkitAudioContext;
            const ctx = new ACtx({ latencyHint: "interactive" });
            const main = ctx.createGain();
            main.connect(ctx.destination);
            const djGain = ctx.createGain();
            djGain.gain.value = 0;
            djGain.connect(main);

            const djLowShelf = ctx.createBiquadFilter();
            djLowShelf.type = "lowshelf";
            djLowShelf.frequency.value = 160;
            djLowShelf.gain.value = 3.2;
            const djHighShelf = ctx.createBiquadFilter();
            djHighShelf.type = "highshelf";
            djHighShelf.frequency.value = 5200;
            djHighShelf.gain.value = -2.0;
            const djLP = ctx.createBiquadFilter();
            djLP.type = "lowpass";
            djLP.frequency.value = 11000;
            djLP.Q.value = 0.55;
            const djComp = ctx.createDynamicsCompressor();
            djComp.threshold.value = -20;
            djComp.knee.value = 10;
            djComp.ratio.value = 2.2;
            djComp.attack.value = 0.004;
            djComp.release.value = 0.12;
            const djMakeup = ctx.createGain();
            djMakeup.gain.value = 1.24;
            djLowShelf.connect(djHighShelf);
            djHighShelf.connect(djLP);
            djLP.connect(djComp);
            djComp.connect(djMakeup);
            djMakeup.connect(djGain);

            function hannCurve(n) {
                const a = new Float32Array(n);
                for (let i = 0; i < n; i++)
                    a[i] = 0.5 - 0.5 * Math.cos((2 * Math.PI * i) / (n - 1));
                let p = 0;
                for (let i = 0; i < n; i++) p = Math.max(p, a[i]);
                for (let i = 0; i < n; i++) a[i] /= p;
                return a;
            }
            const ENV_SAMPLES = 128,
                HANN_ENV = hannCurve(ENV_SAMPLES);

            let buffer = null,
                bufferRev = null,
                duration = 0,
                waReady = false;
            function makeReversed(b) {
                const r = ctx.createBuffer(
                    b.numberOfChannels,
                    b.length,
                    b.sampleRate
                );
                for (let c = 0; c < b.numberOfChannels; c++) {
                    const s = b.getChannelData(c),
                        d = r.getChannelData(c);
                    for (let i = 0, j = s.length - 1; i < s.length; i++, j--)
                        d[i] = s[j];
                }
                return r;
            }
            async function loadAudio() {
                const ab = await (
                    await fetch(AUDIO_URL, { cache: "no-store" })
                ).arrayBuffer();
                buffer = await ctx.decodeAudioData(ab);
                bufferRev = makeReversed(buffer);
                duration = buffer.duration || 0;
                waReady = true;
            }

            const loaderEl = document.getElementById("loader");
            const hintEl = document.getElementById("hint");

            async function initLoad() {
                try {
                    // Only audio + first base (for aspect). Everything else is lazy.
                    await Promise.all([loadAudio(), calibrateAspect()]);
                    recomputeMapping(false);
                    setTimeout(() => recomputeMapping(true), 30);
                    loaderEl.classList.add("hide");
                    hintEl.classList.remove("hide");
                    startScheduler();
                } catch (e) {
                    console.error("Loading failed:", e);
                    loaderEl.textContent = "Failed to load media.";
                }
            }

            const grainSec = GRAIN_MS / 1000,
                hopSec = HOP_MS / 1000,
                jitterMax = MICRO_JITTER_MS / 1000;
            let scheduler = null,
                lastSch = 0;
            let enginePos = 0,
                platterRate = 0.0,
                rateTarget = 0.0,
                lastUserTs = 0;

            const clamp = (v, a, b) => Math.min(Math.max(v, a), b);
            function ramp(node, to, ms) {
                const n = ctx.currentTime,
                    t = Math.max(0.001, ms / 1000);
                node.gain.cancelScheduledValues(n);
                node.gain.setValueAtTime(node.gain.value, n);
                node.gain.linearRampToValueAtTime(to, n + t);
            }

            function scheduleGrain(buf, startClock, offset, rate) {
                const src = ctx.createBufferSource();
                src.buffer = buf;
                src.playbackRate.value = rate;
                const g = ctx.createGain();
                g.gain.setValueCurveAtTime(HANN_ENV, startClock, grainSec);
                src.connect(g);
                g.connect(djLowShelf);
                src.start(startClock, offset, grainSec);
                src.stop(startClock + grainSec);
            }

            function startScheduler() {
                if (scheduler || !waReady) return;
                lastSch = ctx.currentTime;
                scheduler = setInterval(() => {
                    if (!waReady || !mappingReady) return;
                    const now = ctx.currentTime,
                        look = LOOKAHEAD_MS / 1000;
                    while (lastSch < now + look) {
                        const active =
                            performance.now() - lastUserTs < IDLE_HOLD_MS ||
                            Math.abs(platterRate) > RATE_EPS;
                        if (!active) {
                            djLP.frequency.setTargetAtTime(
                                1900,
                                ctx.currentTime,
                                0.05
                            );
                            djHighShelf.gain.setTargetAtTime(
                                -7.0,
                                ctx.currentTime,
                                0.05
                            );
                            ramp(djGain, 0, XFADE_MS);
                            lastSch += hopSec;
                            continue;
                        }

                        const dir = platterRate >= 0 ? +1 : -1;
                        const buf = dir >= 0 ? buffer : bufferRev;

                        const tAudio = lastSch;
                        const wow =
                            WOW_DEPTH * Math.sin(2 * Math.PI * WOW_HZ * tAudio);
                        const fl =
                            FLUT_DEPTH *
                            Math.sin(2 * Math.PI * FLUT_HZ * tAudio);
                        const base = clamp(
                            Math.abs(platterRate),
                            0.45,
                            RATE_CAP
                        );
                        const eff = clamp(
                            base * (1 + wow + fl),
                            0.38,
                            RATE_CAP
                        );

                        const timeSinceUser = performance.now() - lastUserTs;
                        const nearStop =
                            Math.abs(platterRate) < 0.08 && timeSinceUser > 40;
                        const coastStop =
                            Math.abs(platterRate) < 0.03 && timeSinceUser > 140;
                        const stopAmt = coastStop
                            ? 1
                            : nearStop
                            ? 0.4 +
                              (0.6 * (0.08 - Math.abs(platterRate))) / 0.08
                            : 0;

                        let cut = 13500 / (1 + Math.max(0, eff - 1) * 3.6);
                        if (platterRate < 0) cut *= 0.82;
                        const targetCut = cut * (1 - 0.78 * stopAmt);
                        djLP.frequency.setTargetAtTime(
                            Math.max(LP_MIN, Math.min(LP_MAX, targetCut)),
                            ctx.currentTime,
                            0.03
                        );

                        const shelfDb = -2.0 - 5.0 * stopAmt;
                        djHighShelf.gain.setTargetAtTime(
                            shelfDb,
                            ctx.currentTime,
                            0.04
                        );

                        // Follow scroll
                        const tMap = timeFromY(scrollY, duration);
                        enginePos += (tMap - enginePos) * 0.12;

                        const tail = 0.006;
                        let off =
                            dir >= 0
                                ? enginePos
                                : duration - enginePos - grainSec;
                        off = clamp(off, 0, buf.duration - grainSec - tail);

                        ramp(djGain, 1, XFADE_MS);

                        const startAt =
                            lastSch +
                            0.002 +
                            (Math.random() * 2 - 1) * jitterMax;
                        scheduleGrain(buf, startAt, off, eff);
                        const startAt2 = startAt + hopSec / 2;
                        const off2 = clamp(
                            off + (dir >= 0 ? +1 : -1) * (hopSec / 2) * eff,
                            0,
                            buf.duration - grainSec - tail
                        );
                        scheduleGrain(buf, startAt2, off2, eff);

                        enginePos = clamp(
                            enginePos + (dir >= 0 ? +1 : -1) * hopSec * eff,
                            0,
                            duration
                        );
                        lastSch = startAt + hopSec;
                    }
                }, Math.max(5, HOP_MS / 2));
            }

            /* ================== INPUT & VISUALS ================== */
            const feBlur = document.querySelector("#motionBlur feGaussianBlur");
            let blurYVis = 0,
                shiftVis = 0,
                hintAutofaded = false;

            async function unlock() {
                try {
                    if (ctx.state !== "running") await ctx.resume();
                } catch {}
            }
            function onUser(e) {
                if (e && e.isTrusted === false) return;
                unlock();
                lastUserTs = performance.now();
            }
            [
                "wheel",
                "touchstart",
                "touchmove",
                "pointerdown",
                "keydown",
                "mousedown",
            ].forEach((evt) => {
                addEventListener(evt, onUser, { passive: true });
            });

            function timeFromY(y, d) {
                if (!mappingReady || !d) return 0;
                return Math.min(
                    d,
                    Math.max(0, ((y - startY) / (endY - startY)) * d)
                );
            }

            addEventListener(
                "load",
                () => {
                    if ("scrollRestoration" in history)
                        history.scrollRestoration = "manual";
                    scrollTo(0, 0);
                    initLoad();
                },
                { once: true }
            );

            let lastT = performance.now(),
                lastY = scrollY;
            function loop() {
                const now = performance.now(),
                    dt = Math.max(1, now - lastT),
                    dy = scrollY - lastY;
                lastT = now;
                lastY = scrollY;

                if (mappingReady) {
                    if (
                        !hintAutofaded &&
                        !document
                            .getElementById("hint")
                            .classList.contains("hide") &&
                        Math.abs(dy) > 2
                    ) {
                        document.getElementById("hint").classList.add("hide");
                        hintAutofaded = true;
                    }
                    const pxps = (dy * 1000) / dt,
                        torque = pxps * DRAG_SENSITIVITY;
                    rateTarget += torque;
                    if (Math.abs(pxps) < 1.5)
                        rateTarget += (0 - rateTarget) * RETURN_LAMBDA;
                    rateTarget += (0 - rateTarget) * FRICTION_DECAY;

                    platterRate += (rateTarget - platterRate) * 0.25;
                    platterRate = clamp(platterRate, -RATE_CAP, RATE_CAP);

                    const speed = platterRate,
                        absSpeed = Math.abs(speed);
                    let blurTarget = Math.max(
                        0,
                        (absSpeed - BLUR_THRESHOLD) * BLUR_TARGET_GAIN
                    );
                    blurTarget = Math.min(BLUR_MAX, blurTarget);
                    blurYVis = blurYVis + (blurTarget - blurYVis) * BLUR_SMOOTH;
                    feBlur.setAttribute(
                        "stdDeviation",
                        `0 ${blurYVis.toFixed(2)}`
                    );

                    const shiftTarget =
                        Math.sign(speed) *
                        Math.min(SHIFT_MAX, absSpeed * SHIFT_GAIN);
                    shiftVis =
                        shiftVis + (shiftTarget - shiftVis) * SHIFT_SMOOTH;
                    wrap.style.transform = `translateY(${shiftVis.toFixed(
                        1
                    )}px)`;
                }
                requestAnimationFrame(loop);
            }
            requestAnimationFrame(loop);
        </script>
    </body>
</html>
