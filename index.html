<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Scroll ⇄ Audio (Seamless DJ Handoff)</title>
<style>
  html,body{margin:0;background:#0f172a;color:#e5e7eb;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  .wrap{max-width:1200px;margin:0 auto;font-size:0;line-height:0}
  .wrap img{display:block;width:100%;height:auto;margin:0;border:0}
  .hud{position:fixed;left:0;right:0;top:0;display:grid;place-items:center;padding:12px;pointer-events:none;z-index:10}
  .card{pointer-events:auto;background:rgba(15,23,42,.65);backdrop-filter:blur(10px);border-radius:12px;padding:10px 14px;font-size:14px}
  .time{font-variant-numeric:tabular-nums;color:#a3e635}.note{color:#cbd5e1}.hint{color:#facc15}.err{color:#fca5a5}
</style>
</head>
<body>
<div class="hud">
  <div class="card">
    <div><b id="modeLbl">Auto (1×)</b> — scroll/touch/keys for vinyl DJ (↓ fwd, ↑ rev). Pause briefly to return to Auto.</div>
    <div><span id="now" class="time">00:00</span> / <span id="dur" class="time">00:00</span>
      <span id="rate" class="note" style="margin-left:8px;">1.00×</span>
      <span id="status" class="note" style="margin-left:8px;">Loading…</span>
      <span id="hint" class="hint" style="margin-left:8px;">If silent, tap once</span>
    </div>
  </div>
</div>

<div id="wrap" class="wrap" aria-label="Timeline images"></div>
<audio id="audio" src="track.mp3" preload="auto" playsinline muted autoplay></audio>

<script>
/* ===== CONFIG ===== */
const STRIP_COUNT=4, STRIP_PREFIX='strip', STRIP_EXT='png';
const START_DEBOUNCE_MS=300, IDLE_BACK_MS=700, POST_HANDOFF_MUTE_MS=600;
const XFADE_MS=180;

/* Granular (smooth) */
const GRAIN_MS=50, HOP_MS=6, LOOKAHEAD_MS=60;
const ATTACK_MS=2.5, RELEASE_MS=2.5;
const MICRO_JITTER_MS=0.35;          // ±0.35ms start jitter
const PULL_ALPHA_AUTO=0.18;          // how tightly DJ follows native in Auto
const PULL_ALPHA_USER=0.08;          // how tightly DJ follows strip in User
const RATE_CAP=2.3;

/* Vinyl feel */
const DRAG_SENSITIVITY=1/950;
const RETURN_LAMBDA=0.14;
const FRICTION_DECAY=0.0035;
const WOW_HZ=0.6, WOW_DEPTH=0.0028;
const FLUT_HZ=5.5, FLUT_DEPTH=0.0005;

/* ===== STRIPS ===== */
const wrap=document.getElementById('wrap'), strips=[];
for(let i=0;i<=STRIP_COUNT;i++){const im=new Image();im.alt=`strip ${i}`;im.decoding='sync';im.loading='eager';im.src=`${STRIP_PREFIX}${i}.${STRIP_EXT}`;wrap.appendChild(im);strips.push(im);}
let mappingReady=false,startY=0,endY=1;
function recomputeMapping(lock=true){
  if(!strips.length)return;
  const p=(lock&&mappingReady)?(scrollY-startY)/(endY-startY):null;
  const first=strips[0], last=strips[strips.length-1];
  startY=first.offsetTop;
  endY=Math.max(startY+1, last.offsetTop+last.offsetHeight-innerHeight);
  mappingReady=true;
  if(p!=null&&isFinite(p)){const y=startY+Math.min(1,Math.max(0,p))*(endY-startY); if(Math.abs(scrollY-y)>0.5) scrollTo(0,y);}
}
addEventListener('resize',()=>recomputeMapping(true),{passive:true});
addEventListener('load',()=>{recomputeMapping(false); setTimeout(()=>recomputeMapping(true),220);},{once:true});
const yFromTime=(t,d)=>!mappingReady||!d?startY: startY+Math.min(1,Math.max(0,t/d))*(endY-startY);
const timeFromY=(y,d)=>!mappingReady||!d?0      : Math.min(d,Math.max(0,(y-startY)/(endY-startY)*d));

/* ===== HUD ===== */
const nowEl=document.getElementById('now'),durEl=document.getElementById('dur'),
      rateEl=document.getElementById('rate'),statusEl=document.getElementById('status'),
      hintEl=document.getElementById('hint'),modeLbl=document.getElementById('modeLbl');
const fmt=s=>{s=Math.max(0,s|0);const m=(s/60)|0,ss=(s%60)|0;return`${String(m).padStart(2,'0')}:${String(ss).padStart(2,'0')}`};
const clamp=(v,min,max)=>Math.min(Math.max(v,min),max);

/* ===== Native audio ===== */
const audio=document.getElementById('audio'); let audioReady=false,duration=0;
audio.addEventListener('loadedmetadata',()=>{
  audioReady=true; duration=audio.duration||0; durEl.textContent=fmt(duration|0);
  audio.play().then(()=>{statusEl.textContent='Auto (native)'; mode='AUTO';})
               .catch(()=>{statusEl.textContent='Auto (tap/scroll to start)';});
});
audio.addEventListener('playing',()=>{hintEl.style.display='none';});

/* ===== WebAudio ===== */
const ACtx=window.AudioContext||window.webkitAudioContext; const ctx=new ACtx({latencyHint:'interactive'});
const main=ctx.createGain(); main.connect(ctx.destination);
const nativeGain=ctx.createGain(), djGain=ctx.createGain();
nativeGain.gain.value=1; djGain.gain.value=0;
nativeGain.connect(main); djGain.connect(main);
const media=ctx.createMediaElementSource(audio); media.connect(nativeGain);

/* DJ lane processing */
const djFilter=ctx.createBiquadFilter(); djFilter.type='lowpass'; djFilter.frequency.value=15000; djFilter.Q.value=.707;
djFilter.connect(djGain);

/* Raised-cosine (Hann) envelope */
function hannCurve(n){const a=new Float32Array(n); for(let i=0;i<n;i++) a[i]=0.5-0.5*Math.cos(2*Math.PI*i/(n-1)); let p=0; for(let i=0;i<n;i++) p=Math.max(p,a[i]); for(let i=0;i<n;i++) a[i]/=p; return a;}
const ENV_SAMPLES=128, HANN_ENV=hannCurve(ENV_SAMPLES);

/* Decode */
let waBuf=null, waBufRev=null, waReady=false;
function makeReversedBuffer(b){const r=ctx.createBuffer(b.numberOfChannels,b.length,b.sampleRate);
for(let c=0;c<b.numberOfChannels;c++){const s=b.getChannelData(c),d=r.getChannelData(c);for(let i=0,j=s.length-1;i<s.length;i++,j--) d[i]=s[j];}return r;}
(async()=>{try{const ab=await (await fetch('track.mp3',{cache:'no-store'})).arrayBuffer();
waBuf=await ctx.decodeAudioData(ab); waBufRev=makeReversedBuffer(waBuf); waReady=true; startScheduler(); }catch(e){statusEl.innerHTML='<span class="err">Failed to decode track.mp3</span>';}})();

async function ensureUnlocked(){ try{await ctx.resume();}catch{} try{await audio.play();}catch{} audio.muted=false; }

/* ===== Scheduler (always on) ===== */
const grainSec=GRAIN_MS/1000, hopSec=HOP_MS/1000, jitterMax=MICRO_JITTER_MS/1000;
let scheduler=null,lastSch=0;
let enginePos=0;           // DJ timeline (seconds)
let platterRate=1.0;       // signed; <0 = reverse
let rateTarget=1.0;

function startScheduler(){ if(scheduler||!waReady) return; lastSch=ctx.currentTime;
  scheduler=setInterval(()=>{
    if(!waReady) return;
    const now=ctx.currentTime, look=LOOKAHEAD_MS/1000;
    while(lastSch < now+look){
      // Follow source depending on mode
      if(mode==='AUTO' && audioReady) {
        const tNat = audio.currentTime || 0;
        enginePos += (tNat - enginePos) * PULL_ALPHA_AUTO; // shadow-follow native
        platterRate += (1.0 - platterRate) * 0.3;          // keep near 1× in Auto
        rateTarget  += (1.0 - rateTarget)  * 0.3;
      } else if(mode==='USER') {
        const tMap=timeFromY(scrollY, waBuf.duration);
        enginePos += (tMap - enginePos) * PULL_ALPHA_USER;  // follow strip gently
      } else if(mode==='AUTO_SIM'){
        // 1× granular auto if native blocked
        platterRate += (1.0 - platterRate) * 0.25;
        rateTarget  += (1.0 - rateTarget)  * 0.25;
      }

      const dir = platterRate>=0?+1:-1, buf = dir>=0?waBuf:waBufRev;
      // wow & flutter
      const tAudio=now;
      const wow=WOW_DEPTH*Math.sin(2*Math.PI*WOW_HZ*tAudio);
      const fl =FLUT_DEPTH*Math.sin(2*Math.PI*FLUT_HZ*tAudio);
      const base=clamp(Math.abs(platterRate),0.45,RATE_CAP);
      const eff =clamp(base*(1+wow+fl),0.35,RATE_CAP);

      // anti-squeak
      let cut = 14000 / (1 + Math.max(0, eff - 1) * 3.0);
      if (platterRate < 0) cut *= 0.85;
      djFilter.frequency.setTargetAtTime(clamp(cut, 3500, 16000), ctx.currentTime, 0.02);

      // offsets
      const tail=0.005; // 5ms tail safety
      let off = dir>=0 ? enginePos : (waBuf.duration - enginePos - grainSec);
      off = clamp(off, 0, buf.duration - grainSec - tail);

      // nodes
      const src=ctx.createBufferSource(); src.buffer=buf; src.playbackRate.value=eff;
      const g=ctx.createGain(); const startAt=lastSch+0.002 + ((Math.random()*2-1)*jitterMax), endAt=startAt+grainSec;
      g.gain.setValueCurveAtTime(HANN_ENV, startAt, grainSec);
      src.connect(g); g.connect(djFilter);
      src.start(startAt, off, grainSec); src.stop(endAt);

      // advance
      enginePos = clamp(enginePos + (dir>=0?+1:-1)*hopSec*eff, 0, waBuf.duration);
      lastSch=endAt;
    }
  }, Math.max(5, HOP_MS/2));
}

/* ===== Modes & crossfades ===== */
let mode='AUTO'; let lastUserTs=performance.now(), ignoreInputUntil=0;
const bootTs=performance.now();
function setModeLabel(){ modeLbl.textContent=(mode==='USER'?'You control':'Auto (1×)'); }
function rampGain(node,to,ms){const n=ctx.currentTime,t=ms/1000; node.gain.cancelScheduledValues(n); node.gain.setValueAtTime(node.gain.value,n); node.gain.linearRampToValueAtTime(to,n+t);}

function enterUser(){
  if(mode==='USER') return;
  // No jumping: DJ engine already shadow-followed native
  mode='USER'; setModeLabel(); statusEl.textContent='DJ mode';
  audio.muted=true;
  rampGain(djGain,1,XFADE_MS);     // fade DJ in
  rampGain(nativeGain,0,XFADE_MS); // fade native out
}
function exitUser(){
  if(mode!=='USER') return;
  // Handback with invisible crossfade: align native gently, then fade up
  if(audioReady){
    audio.muted=true;
    audio.play().catch(()=>{});
    // Set native close to enginePos, but only if meaningfully different
    const delta=enginePos - (audio.currentTime||0);
    if(Math.abs(delta)>0.08){ audio.currentTime = enginePos; }
  }
  mode='AUTO'; setModeLabel(); statusEl.textContent='Auto (native)';
  rampGain(nativeGain,1,XFADE_MS);
  rampGain(djGain,0,XFADE_MS);
  ignoreInputUntil = performance.now() + POST_HANDOFF_MUTE_MS; // ignore tiny inertia
}

/* ===== Inputs ===== */
function markUserControl(e){
  const now=performance.now();
  if(now<ignoreInputUntil) return;
  if(now-bootTs<START_DEBOUNCE_MS) return;
  if(e && e.isTrusted===false) return;
  ensureUnlocked();
  lastUserTs=now;
  if(mode!=='USER') enterUser();
}
addEventListener('wheel',e=>markUserControl(e),{passive:true});
addEventListener('touchstart',e=>markUserControl(e),{passive:true});
addEventListener('touchmove',e=>markUserControl(e),{passive:true});
addEventListener('pointerdown',e=>markUserControl(e),{passive:true});
addEventListener('keydown',e=>{const k=['ArrowUp','ArrowDown','PageUp','PageDown','Home','End',' ','Spacebar']; if(k.includes(e.key)) markUserControl(e);},{passive:true});

/* ===== Loop ===== */
let lastT=performance.now(), lastY=scrollY; let promoteTick=0;
function loop(){
  const now=performance.now(), dt=Math.max(1,now-lastT); const dy=scrollY-lastY; lastT=now; lastY=scrollY;
  if(!mappingReady){ requestAnimationFrame(loop); return; }

  if(mode==='AUTO'){
    if(audioReady && !audio.paused){
      const y=yFromTime(audio.currentTime,duration);
      if(Math.abs(scrollY - y) > 0.5) scrollTo(0,y);
      nowEl.textContent=fmt(audio.currentTime|0); rateEl.textContent='1.00×'; statusEl.textContent='Auto (native)';
    } else if(waReady){
      mode='AUTO_SIM'; setModeLabel(); statusEl.textContent='Auto (granular bootstrap)';
      rampGain(djGain,1,120); rampGain(nativeGain,0,120);
    }

  } else if(mode==='AUTO_SIM'){
    // granular 1× auto; keep trying to promote to native
    const y=yFromTime(enginePos, waBuf?waBuf.duration:duration||0); if(Math.abs(scrollY-y)>0.5) scrollTo(0,y);
    nowEl.textContent=fmt(enginePos|0); rateEl.textContent='1.00×';
    if(audioReady && (++promoteTick%30===0)){
      audio.play().then(()=>{ audio.muted=false; rampGain(nativeGain,1,XFADE_MS); rampGain(djGain,0,XFADE_MS);
        setTimeout(()=>{ mode='AUTO'; setModeLabel(); statusEl.textContent='Auto (native)'; }, XFADE_MS+40);
      }).catch(()=>{});
    }

  } else if(mode==='USER'){
    // Convert scroll velocity to platter torque
    const pxps=(dy*1000)/dt;
    const torque=pxps*DRAG_SENSITIVITY;
    rateTarget += torque;
    rateTarget += (1.0 - rateTarget) * RETURN_LAMBDA;
    if(Math.abs(pxps)<1.5) rateTarget += (1.0 - rateTarget) * FRICTION_DECAY;
    platterRate += (rateTarget - platterRate) * 0.26;
    platterRate = clamp(platterRate, -RATE_CAP, RATE_CAP);
    rateEl.textContent=`${Math.abs(platterRate).toFixed(2)}×`;
    if(waReady) nowEl.textContent=fmt(enginePos|0);

    // Calm detector → smooth handback
    const calm = (now - lastUserTs) >= IDLE_BACK_MS && Math.abs(pxps) < 1.2 && Math.abs(platterRate-1.0) < 0.10;
    if(calm) exitUser();
  }

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// Kick mapping
recomputeMapping(false);
</script>
</body>
</html>
