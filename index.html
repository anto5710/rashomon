<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Scroll ⇄ Audio (Seamless DJ • Minimal Badge)</title>
<style>
  html,body{margin:0;background:#0f172a;color:#e5e7eb;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  .wrap{max-width:1200px;margin:0 auto;font-size:0;line-height:0}
  .wrap img{display:block;width:100%;height:auto;margin:0;border:0}

  /* Minimal circular badge */
  .badge{
    position:fixed; right:16px; bottom:16px; z-index:20;
    width:58px; height:58px; border-radius:9999px;
    display:grid; place-items:center;
    font-variant-numeric:tabular-nums;
    background:rgba(15,23,42,.68); color:#e5e7eb;
    border:1px solid rgba(148,163,184,.25);
    box-shadow:0 8px 24px rgba(0,0,0,.35);
    user-select:none; -webkit-user-select:none; touch-action:manipulation;
  }
  .badge .icon{font-size:16px; line-height:1; opacity:.9}
  .badge .rate{font-size:12px; line-height:1; opacity:.9}
  .badge.auto{ background:rgba(2,6,23,.65); }
  .badge.user{ background:rgba(30,41,59,.72); }
</style>
</head>
<body>

<!-- Timeline strips -->
<div id="wrap" class="wrap" aria-label="Timeline images"></div>

<!-- Native audio (runs in parallel, we crossfade) -->
<audio id="audio" src="track.mp3" preload="auto" playsinline muted autoplay></audio>

<!-- Minimal circular badge -->
<div id="badge" class="badge auto" aria-live="polite" aria-atomic="true" role="status" title="Scroll / tap to take control">
  <div class="icon" id="badgeIcon">▶</div>
  <div class="rate" id="badgeRate">1.00×</div>
</div>

<script>
/* ==================== CONFIG (from seamless bar-UI build) ==================== */
const STRIP_COUNT=4, STRIP_PREFIX='strip', STRIP_EXT='png';
const START_DEBOUNCE_MS=300, IDLE_BACK_MS=700, POST_HANDOFF_MUTE_MS=600;
const XFADE_MS=180;

/* Granular (smooth) */
const GRAIN_MS=50, HOP_MS=6, LOOKAHEAD_MS=60;
const ATTACK_MS=2.5, RELEASE_MS=2.5;
const MICRO_JITTER_MS=0.35;            // ±0.35ms jitter
const PULL_ALPHA_AUTO=0.18;            // DJ shadow-follows native in AUTO
const PULL_ALPHA_USER=0.08;            // DJ follows strip in USER
const RATE_CAP=2.3;

/* Vinyl feel */
const DRAG_SENSITIVITY=1/950;
const RETURN_LAMBDA=0.14;
const FRICTION_DECAY=0.0035;
const WOW_HZ=0.6, WOW_DEPTH=0.0028;
const FLUT_HZ=5.5, FLUT_DEPTH=0.0005;

if ('scrollRestoration' in history) history.scrollRestoration='manual';

/* ==================== STRIPS / SCROLL MAPPING ==================== */
const wrap=document.getElementById('wrap'), strips=[];
for(let i=0;i<=STRIP_COUNT;i++){
  const im=new Image(); im.alt=`strip ${i}`; im.decoding='sync'; im.loading='eager';
  im.src=`${STRIP_PREFIX}${i}.${STRIP_EXT}`; wrap.appendChild(im); strips.push(im);
}
let mappingReady=false,startY=0,endY=1;
function recomputeMapping(lock=true){
  if(!strips.length)return;
  const p=(lock&&mappingReady)?(scrollY-startY)/(endY-startY):null;
  const first=strips[0], last=strips[strips.length-1];
  startY=first.offsetTop;
  endY=Math.max(startY+1, last.offsetTop+last.offsetHeight-innerHeight);
  mappingReady=true;
  if(p!=null&&isFinite(p)){
    const y=startY+Math.min(1,Math.max(0,p))*(endY-startY);
    if(Math.abs(scrollY-y)>0.5) scrollTo(0,y);
  }
}
addEventListener('resize',()=>recomputeMapping(true),{passive:true});
addEventListener('load',()=>{recomputeMapping(false); setTimeout(()=>recomputeMapping(true),220);},{once:true});
const yFromTime=(t,d)=>!mappingReady||!d?startY: startY+Math.min(1,Math.max(0,t/d))*(endY-startY);
const timeFromY=(y,d)=>!mappingReady||!d?0      : Math.min(d,Math.max(0,(y-startY)/(endY-startY)*d));

/* ==================== Minimal Badge UI ==================== */
const badge=document.getElementById('badge');
const badgeIcon=document.getElementById('badgeIcon');
const badgeRate=document.getElementById('badgeRate');
function setBadge(mode, rate){
  const rTxt=`${Math.abs(rate).toFixed(2)}×`;
  badgeRate.textContent=rTxt;
  if(mode==='USER'){ badge.classList.remove('auto'); badge.classList.add('user'); badgeIcon.textContent='☛'; }
  else            { badge.classList.remove('user'); badge.classList.add('auto'); badgeIcon.textContent='▶'; }
}

/* ==================== Native <audio> ==================== */
const audio=document.getElementById('audio');
let audioReady=false,duration=0;
audio.addEventListener('loadedmetadata',()=>{
  audioReady=true; duration=audio.duration||0;
  audio.play().then(()=>{ mode='AUTO'; }).catch(()=>{ /* may start in AUTO_SIM */ });
});

/* ==================== WebAudio (granular lane) ==================== */
const ACtx=window.AudioContext||window.webkitAudioContext;
const ctx=new ACtx({latencyHint:'interactive'});
const main=ctx.createGain(); main.connect(ctx.destination);
const nativeGain=ctx.createGain(), djGain=ctx.createGain();
nativeGain.gain.value=1; djGain.gain.value=0;
nativeGain.connect(main); djGain.connect(main);
const media=ctx.createMediaElementSource(audio); media.connect(nativeGain);

/* Anti-squeak low-pass */
const djFilter=ctx.createBiquadFilter(); djFilter.type='lowpass'; djFilter.frequency.value=15000; djFilter.Q.value=.707;
djFilter.connect(djGain);

/* Raised-cosine (Hann) envelope */
function hannCurve(n){const a=new Float32Array(n); for(let i=0;i<n;i++) a[i]=0.5-0.5*Math.cos(2*Math.PI*i/(n-1)); let p=0; for(let i=0;i<n;i++) p=Math.max(p,a[i]); for(let i=0;i<n;i++) a[i]/=p; return a;}
const ENV_SAMPLES=128, HANN_ENV=hannCurve(ENV_SAMPLES);

/* Decode buffers */
let waBuf=null, waBufRev=null, waReady=false;
function makeReversedBuffer(b){const r=ctx.createBuffer(b.numberOfChannels,b.length,b.sampleRate);
for(let c=0;c<b.numberOfChannels;c++){const s=b.getChannelData(c),d=r.getChannelData(c);for(let i=0,j=s.length-1;i<s.length;i++,j--) d[i]=s[j];}return r;}
(async()=>{try{
  const ab=await (await fetch('track.mp3',{cache:'no-store'})).arrayBuffer();
  waBuf=await ctx.decodeAudioData(ab); waBufRev=makeReversedBuffer(waBuf); waReady=true; startScheduler();
}catch(e){ /* silent */ }})();

/* ==================== Scheduler (always on, from bar-UI build) ==================== */
const grainSec=GRAIN_MS/1000, hopSec=HOP_MS/1000, jitterMax=MICRO_JITTER_MS/1000;
let scheduler=null,lastSch=0;
let enginePos=0, platterRate=1.0, rateTarget=1.0;

function startScheduler(){ if(scheduler||!waReady) return; lastSch=ctx.currentTime;
  scheduler=setInterval(()=>{
    if(!waReady) return;
    const now=ctx.currentTime, look=LOOKAHEAD_MS/1000;
    while(lastSch < now+look){
      // Follow source depending on mode (AUTO shadow-follow; USER follows strip; AUTO_SIM = 1× granular)
      if(mode==='AUTO' && audioReady) {
        const tNat = audio.currentTime || 0;
        enginePos += (tNat - enginePos) * PULL_ALPHA_AUTO;
        platterRate += (1.0 - platterRate) * 0.3;
        rateTarget  += (1.0 - rateTarget)  * 0.3;
      } else if(mode==='USER') {
        const tMap=timeFromY(scrollY, waBuf.duration);
        enginePos += (tMap - enginePos) * PULL_ALPHA_USER;
      } else if(mode==='AUTO_SIM'){
        platterRate += (1.0 - platterRate) * 0.25;
        rateTarget  += (1.0 - rateTarget)  * 0.25;
      }

      const dir = platterRate>=0?+1:-1, buf = dir>=0?waBuf:waBufRev;

      // wow & flutter
      const wow=WOW_DEPTH*Math.sin(2*Math.PI*WOW_HZ*now);
      const fl =FLUT_HZ? (FLUT_DEPTH*Math.sin(2*Math.PI*FLUT_HZ*now)) : 0;
      const base=Math.min(RATE_CAP, Math.max(0.45, Math.abs(platterRate)));
      const eff =Math.min(RATE_CAP, Math.max(0.35, base*(1+wow+fl)));

      // dynamic LPF (darker when fast/reverse)
      let cut = 14000 / (1 + Math.max(0, eff - 1) * 3.0);
      if (platterRate < 0) cut *= 0.85;
      djFilter.frequency.setTargetAtTime(Math.min(16000, Math.max(3500, cut)), ctx.currentTime, 0.02);

      // offsets (5ms safety tail)
      const tail=0.005;
      let off = dir>=0 ? enginePos : (waBuf.duration - enginePos - grainSec);
      off = Math.min(Math.max(0, off), buf.duration - grainSec - tail);

      // grain
      const src=ctx.createBufferSource(); src.buffer=buf; src.playbackRate.value=eff;
      const g=ctx.createGain(); const startAt=lastSch+0.002 + ((Math.random()*2-1)*jitterMax), endAt=startAt+grainSec;
      g.gain.setValueCurveAtTime(HANN_ENV, startAt, grainSec);
      src.connect(g); g.connect(djFilter);
      src.start(startAt, off, grainSec); src.stop(endAt);

      enginePos = Math.min(Math.max(0, enginePos + (dir>=0?+1:-1)*hopSec*eff), waBuf.duration);
      lastSch=endAt;
    }
  }, Math.max(5, HOP_MS/2));
}

/* ==================== Modes & seamless crossfades (from bar-UI build) ==================== */
let mode='AUTO'; let lastUserTs=performance.now(), ignoreInputUntil=0;
const bootTs=performance.now();
function rampGain(node,to,ms){const n=ctx.currentTime,t=ms/1000; node.gain.cancelScheduledValues(n); node.gain.setValueAtTime(node.gain.value,n); node.gain.linearRampToValueAtTime(to,n+t);}

function enterUser(){
  if(mode==='USER') return;
  mode='USER';
  audio.muted=true;
  rampGain(djGain,1,XFADE_MS);     // DJ up
  rampGain(nativeGain,0,XFADE_MS); // native down
  setBadge(mode, platterRate);
}
function exitUser(){
  if(mode!=='USER') return;
  if(audioReady){
    audio.muted=true; audio.play().catch(()=>{});
    const delta=enginePos - (audio.currentTime||0);
    if(Math.abs(delta)>0.08) audio.currentTime=enginePos; // nudge native close
  }
  mode='AUTO';
  rampGain(nativeGain,1,XFADE_MS); rampGain(djGain,0,XFADE_MS);
  ignoreInputUntil = performance.now() + POST_HANDOFF_MUTE_MS; // ignore inertial bumps
  setBadge(mode, 1.0);
}

/* ==================== Input handling (same logic, minimal UI) ==================== */
async function ensureUnlocked(){ try{await ctx.resume();}catch{} try{await audio.play();}catch{} audio.muted=false; }
function markUserControl(e){
  const now=performance.now();
  if(now<ignoreInputUntil) return;
  if(now-bootTs<START_DEBOUNCE_MS) return;
  if(e && e.isTrusted===false) return;
  ensureUnlocked();
  lastUserTs=now;
  if(mode!=='USER') enterUser();
}
['wheel','touchstart','touchmove','pointerdown','keydown','mousedown'].forEach(evt=>{
  addEventListener(evt, markUserControl, {passive:true});
});

/* ==================== Main loop (AUTO / AUTO_SIM / USER) ==================== */
let lastT=performance.now(), lastY=scrollY; let promoteTick=0;
function loop(){
  const now=performance.now(), dt=Math.max(1,now-lastT), dy=scrollY-lastY; lastT=now; lastY=scrollY;
  if(!mappingReady){ requestAnimationFrame(loop); return; }

  if(mode==='AUTO'){
    if(audioReady && !audio.paused){
      const y=yFromTime(audio.currentTime, duration);
      if(Math.abs(scrollY-y)>0.5) scrollTo(0,y);
      setBadge(mode, 1.0);
    } else if(waReady){
      // autoplay blocked → audible granular auto
      mode='AUTO_SIM';
      rampGain(djGain,1,140); rampGain(nativeGain,0,140);
      setBadge('AUTO', 1.0);
    }

  } else if(mode==='AUTO_SIM'){
    const y=yFromTime(enginePos, waBuf?waBuf.duration:duration||0);
    if(Math.abs(scrollY-y)>0.5) scrollTo(0,y);
    setBadge('AUTO', 1.0);
    // periodically try promote to native
    if(audioReady && (++promoteTick%30===0)){
      audio.play().then(()=>{ audio.muted=false; rampGain(nativeGain,1,XFADE_MS); rampGain(djGain,0,XFADE_MS);
        setTimeout(()=>{ mode='AUTO'; }, XFADE_MS+40);
      }).catch(()=>{});
    }

  } else if(mode==='USER'){
    // Platter physics from scroll
    const pxps=(dy*1000)/dt;
    const torque=pxps*DRAG_SENSITIVITY;
    rateTarget += torque;
    rateTarget += (1.0 - rateTarget) * RETURN_LAMBDA;
    if(Math.abs(pxps)<1.5) rateTarget += (1.0 - rateTarget) * FRICTION_DECAY;
    platterRate += (rateTarget - platterRate) * 0.26;
    platterRate = Math.min(Math.max(platterRate, -RATE_CAP), RATE_CAP);
    setBadge(mode, platterRate);

    // Calm detector → smooth handback to AUTO
    const calm = (now - lastUserTs) >= IDLE_BACK_MS && Math.abs(pxps) < 1.2 && Math.abs(platterRate-1.0) < 0.10;
    if(calm) exitUser();
  }

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// initial layout
recomputeMapping(false);
</script>
</body>
</html>
