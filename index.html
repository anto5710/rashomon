<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />
        <title>Scroll ⇄ Audio (Ultra-Smooth DJ v2 • Minimal Badge)</title>
        <style>
            html,
            body {
                margin: 0;
                background: #0f172a;
                color: #e5e7eb;
                font-family: system-ui, -apple-system, Segoe UI, Roboto,
                    Helvetica, Arial, sans-serif;
            }
            .wrap {
                max-width: 1200px;
                margin: 0 auto;
                font-size: 0;
                line-height: 0;
            }
            .wrap img {
                display: block;
                width: 100%;
                height: auto;
                margin: 0;
                border: 0;
            }
            .badge {
                position: fixed;
                right: 16px;
                bottom: 16px;
                z-index: 20;
                width: 58px;
                height: 58px;
                border-radius: 9999px;
                display: grid;
                place-items: center;
                font-variant-numeric: tabular-nums;
                background: rgba(15, 23, 42, 0.68);
                color: #e5e7eb;
                border: 1px solid rgba(148, 163, 184, 0.25);
                box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
                user-select: none;
                -webkit-user-select: none;
                touch-action: manipulation;
            }
            .badge .icon {
                font-size: 16px;
                line-height: 1;
                opacity: 0.9;
            }
            .badge .rate {
                font-size: 12px;
                line-height: 1;
                opacity: 0.9;
            }
            .badge.auto {
                background: rgba(2, 6, 23, 0.65);
            }
            .badge.user {
                background: rgba(30, 41, 59, 0.72);
            }
        </style>
    </head>
    <body>
        <!-- Timeline strips -->
        <div id="wrap" class="wrap" aria-label="Timeline images"></div>

        <!-- Native audio (never muted) -->
        <audio
            id="audio"
            src="track.mp3"
            preload="auto"
            playsinline
            autoplay
        ></audio>

        <!-- Minimal circular badge -->
        <div
            id="badge"
            class="badge auto"
            aria-live="polite"
            aria-atomic="true"
            role="status"
            title="Scroll / tap to take control"
        >
            <div class="icon" id="badgeIcon">▶</div>
            <div class="rate" id="badgeRate">1.00×</div>
        </div>

        <script>
            /* ===== CONFIG ===== */
            const STRIP_COUNT = 4,
                STRIP_PREFIX = "pngs/strip",
                STRIP_EXT = "png";
            const START_DEBOUNCE_MS = 300,
                IDLE_BACK_MS = 700,
                POST_HANDOFF_MUTE_MS = 600;
            const XFADE_MS = 220;

            /* Granular (ultra-smooth) */
            const GRAIN_MS = 100,
                HOP_MS = 4,
                LOOKAHEAD_MS = 80;
            const POLY = 2; // spawn 2 grains per hop (staggered)
            const MICRO_JITTER_MS = 0.25;
            const PULL_ALPHA_AUTO = 0.22,
                PULL_ALPHA_USER = 0.11;
            const RATE_CAP = 2.0;

            /* Vinyl feel */
            const DRAG_SENSITIVITY = 1 / 980,
                RETURN_LAMBDA = 0.12,
                FRICTION_DECAY = 0.0035;
            const WOW_HZ = 0.6,
                WOW_DEPTH = 0.0023,
                FLUT_HZ = 5.5,
                FLUT_DEPTH = 0.0004;

            /* Hybrid near-1× with hysteresis */
            const HYBRID_ENTER_MIN = 0.8,
                HYBRID_ENTER_MAX = 1.35; // enter window
            const HYBRID_EXIT_MIN = 0.75,
                HYBRID_EXIT_MAX = 1.4; // exit window (wider → sticky)
            const HYBRID_VEL_PXPS = 2.0; // calm velocity
            const HYBRID_RAMP_MS = 180;
            const HYBRID_STICK_MS = 220; // dwell to enter

            if ("scrollRestoration" in history)
                history.scrollRestoration = "manual";

            /* ===== STRIPS / SCROLL MAPPING ===== */
            const wrap = document.getElementById("wrap"),
                strips = [];
            for (let i = 0; i <= STRIP_COUNT; i++) {
                const im = new Image();
                im.alt = `strip ${i}`;
                im.decoding = "sync";
                im.loading = "eager";
                im.src = `${STRIP_PREFIX}${i}.${STRIP_EXT}`;
                wrap.appendChild(im);
                strips.push(im);
            }
            let mappingReady = false,
                startY = 0,
                endY = 1;
            function recomputeMapping(lock = true) {
                if (!strips.length) return;
                const p =
                    lock && mappingReady
                        ? (scrollY - startY) / (endY - startY)
                        : null;
                const first = strips[0],
                    last = strips[strips.length - 1];
                startY = first.offsetTop;
                endY = Math.max(
                    startY + 1,
                    last.offsetTop + last.offsetHeight - innerHeight
                );
                mappingReady = true;
                if (p != null && isFinite(p)) {
                    const y =
                        startY + Math.min(1, Math.max(0, p)) * (endY - startY);
                    if (Math.abs(scrollY - y) > 0.5) scrollTo(0, y);
                }
            }
            addEventListener("resize", () => recomputeMapping(true), {
                passive: true,
            });
            addEventListener(
                "load",
                () => {
                    recomputeMapping(false);
                    setTimeout(() => recomputeMapping(true), 220);
                },
                { once: true }
            );
            const yFromTime = (t, d) =>
                !mappingReady || !d
                    ? startY
                    : startY +
                      Math.min(1, Math.max(0, t / d)) * (endY - startY);
            const timeFromY = (y, d) =>
                !mappingReady || !d
                    ? 0
                    : Math.min(
                          d,
                          Math.max(0, ((y - startY) / (endY - startY)) * d)
                      );

            /* ===== Badge UI ===== */
            const badge = document.getElementById("badge");
            const badgeIcon = document.getElementById("badgeIcon");
            const badgeRate = document.getElementById("badgeRate");
            function setBadge(mode, rate) {
                const rTxt = `${Math.abs(rate).toFixed(2)}×`;
                badgeRate.textContent = rTxt;
                if (mode === "USER" || mode === "USER_HYBRID") {
                    badge.classList.remove("auto");
                    badge.classList.add("user");
                    badgeIcon.textContent = "☛";
                } else {
                    badge.classList.remove("user");
                    badge.classList.add("auto");
                    badgeIcon.textContent = "▶";
                }
            }

            /* ===== Native <audio> ===== */
            const audio = document.getElementById("audio");
            let audioReady = false,
                duration = 0;
            audio.volume = 1.0;
            audio.playbackRate = 1.0;
            audio.addEventListener("loadedmetadata", () => {
                audioReady = true;
                duration = audio.duration || 0;
                audio.play().catch(() => {});
            });

            /* ===== WebAudio graph ===== */
            const ACtx = window.AudioContext || window.webkitAudioContext;
            const ctx = new ACtx({ latencyHint: "interactive" });
            const main = ctx.createGain();
            main.connect(ctx.destination);
            const nativeGain = ctx.createGain(),
                djGain = ctx.createGain();
            nativeGain.gain.value = 1;
            djGain.gain.value = 0;
            nativeGain.connect(main);
            djGain.connect(main);
            const media = ctx.createMediaElementSource(audio);
            media.connect(nativeGain);

            /* DJ lane tone & dynamics */
            const djLowShelf = ctx.createBiquadFilter();
            djLowShelf.type = "lowshelf";
            djLowShelf.frequency.value = 160;
            djLowShelf.gain.value = 3.2;
            const djHighShelf = ctx.createBiquadFilter();
            djHighShelf.type = "highshelf";
            djHighShelf.frequency.value = 5200;
            djHighShelf.gain.value = -1.2;
            const djLP = ctx.createBiquadFilter();
            djLP.type = "lowpass";
            djLP.frequency.value = 15000;
            djLP.Q.value = 0.707;
            const djComp = ctx.createDynamicsCompressor();
            djComp.threshold.value = -20;
            djComp.knee.value = 10;
            djComp.ratio.value = 2.2;
            djComp.attack.value = 0.004;
            djComp.release.value = 0.12;
            const djMakeup = ctx.createGain();
            djMakeup.gain.value = 1.22;

            djLowShelf.connect(djHighShelf);
            djHighShelf.connect(djLP);
            djLP.connect(djComp);
            djComp.connect(djMakeup);
            djMakeup.connect(djGain);

            /* Hann window */
            function hannCurve(n) {
                const a = new Float32Array(n);
                for (let i = 0; i < n; i++)
                    a[i] = 0.5 - 0.5 * Math.cos((2 * Math.PI * i) / (n - 1));
                let p = 0;
                for (let i = 0; i < n; i++) p = Math.max(p, a[i]);
                for (let i = 0; i < n; i++) a[i] /= p;
                return a;
            }
            const ENV_SAMPLES = 128,
                HANN_ENV = hannCurve(ENV_SAMPLES);

            /* Decode buffers */
            let waBuf = null,
                waBufRev = null,
                waReady = false;
            function makeReversedBuffer(b) {
                const r = ctx.createBuffer(
                    b.numberOfChannels,
                    b.length,
                    b.sampleRate
                );
                for (let c = 0; c < b.numberOfChannels; c++) {
                    const s = b.getChannelData(c),
                        d = r.getChannelData(c);
                    for (let i = 0, j = s.length - 1; i < s.length; i++, j--)
                        d[i] = s[j];
                }
                return r;
            }
            (async () => {
                try {
                    const ab = await (
                        await fetch("track.mp3", { cache: "no-store" })
                    ).arrayBuffer();
                    waBuf = await ctx.decodeAudioData(ab);
                    waBufRev = makeReversedBuffer(waBuf);
                    waReady = true;
                    startScheduler();
                } catch (e) {
                    console.warn("decode failed", e);
                }
            })();

            /* Helpers */
            const clamp = (v, a, b) => Math.min(Math.max(v, a), b);

            /* ===== Scheduler (dual-poly grains) ===== */
            const grainSec = GRAIN_MS / 1000,
                hopSec = HOP_MS / 1000,
                jitterMax = MICRO_JITTER_MS / 1000;
            let scheduler = null,
                lastSch = 0;
            let enginePos = 0,
                platterRate = 1.0,
                rateTarget = 1.0;

            function scheduleGrain(buf, startClock, offset, rate) {
                const src = ctx.createBufferSource();
                src.buffer = buf;
                src.playbackRate.value = rate;
                const g = ctx.createGain();
                g.gain.setValueCurveAtTime(HANN_ENV, startClock, grainSec);
                src.connect(g);
                g.connect(djLowShelf);
                src.start(startClock, offset, grainSec);
                src.stop(startClock + grainSec);
            }

            function startScheduler() {
                if (scheduler || !waReady) return;
                lastSch = ctx.currentTime;
                scheduler = setInterval(() => {
                    if (!waReady) return;
                    const now = ctx.currentTime,
                        look = LOOKAHEAD_MS / 1000;
                    while (lastSch < now + look) {
                        // Follow targets
                        if (mode === "AUTO" && audioReady) {
                            const tNat = audio.currentTime || 0;
                            enginePos += (tNat - enginePos) * PULL_ALPHA_AUTO;
                            platterRate += (1.0 - platterRate) * 0.26;
                            rateTarget += (1.0 - rateTarget) * 0.26;
                        } else if (mode === "USER" || mode === "USER_HYBRID") {
                            const tMap = timeFromY(scrollY, waBuf.duration);
                            enginePos += (tMap - enginePos) * PULL_ALPHA_USER;
                        } else if (mode === "AUTO_SIM") {
                            platterRate += (1.0 - platterRate) * 0.24;
                            rateTarget += (1.0 - rateTarget) * 0.24;
                        }

                        // Wow/flutter and effective playback rate
                        const dir = platterRate >= 0 ? +1 : -1;
                        const buf = dir >= 0 ? waBuf : waBufRev;
                        const tAudio = lastSch;
                        const wow =
                            WOW_DEPTH * Math.sin(2 * Math.PI * WOW_HZ * tAudio);
                        const fl =
                            FLUT_DEPTH *
                            Math.sin(2 * Math.PI * FLUT_HZ * tAudio);
                        const base = clamp(
                            Math.abs(platterRate),
                            0.45,
                            RATE_CAP
                        );
                        const eff = clamp(
                            base * (1 + wow + fl),
                            0.38,
                            RATE_CAP
                        );

                        // Dynamic LPF — darker at high/negative rates
                        let cut = 14500 / (1 + Math.max(0, eff - 1) * 3.4);
                        if (platterRate < 0) cut *= 0.85;
                        djLP.frequency.setTargetAtTime(
                            clamp(cut, 3000, 16000),
                            ctx.currentTime,
                            0.02
                        );

                        // Choose offset, safety tail
                        const tail = 0.006;
                        let off =
                            dir >= 0
                                ? enginePos
                                : waBuf.duration - enginePos - grainSec;
                        off = clamp(off, 0, buf.duration - grainSec - tail);

                        // Primary grain
                        const startAt =
                            lastSch +
                            0.002 +
                            (Math.random() * 2 - 1) * jitterMax;
                        scheduleGrain(buf, startAt, off, eff);

                        // Staggered second grain for thicker overlap (half-hop later)
                        const startAt2 = startAt + hopSec / 2;
                        const off2 = clamp(
                            off + (dir >= 0 ? +1 : -1) * (hopSec / 2) * eff,
                            0,
                            buf.duration - grainSec - tail
                        );
                        scheduleGrain(buf, startAt2, off2, eff);

                        // Advance the engine clock by one hop (not by poly)
                        enginePos = clamp(
                            enginePos + (dir >= 0 ? +1 : -1) * hopSec * eff,
                            0,
                            waBuf.duration
                        );
                        lastSch = startAt + hopSec; // keep scheduling tightly packed
                    }
                }, Math.max(5, HOP_MS / 2));
            }

            /* ===== Modes & crossfades ===== */
            let mode = "AUTO";
            let lastUserTs = performance.now(),
                ignoreInputUntil = 0;
            const bootTs = performance.now();
            function rampGain(node, to, ms) {
                const n = ctx.currentTime,
                    t = ms / 1000;
                node.gain.cancelScheduledValues(n);
                node.gain.setValueAtTime(node.gain.value, n);
                node.gain.linearRampToValueAtTime(to, n + t);
            }

            function enterUser() {
                if (mode === "USER" || mode === "USER_HYBRID") return;
                mode = "USER";
                rampGain(djGain, 1, XFADE_MS); // DJ up
                rampGain(nativeGain, 0, XFADE_MS); // native down
                setBadge(mode, platterRate);
            }
            function exitUser() {
                if (mode !== "USER" && mode !== "USER_HYBRID") return;
                if (audioReady) {
                    const delta = enginePos - (audio.currentTime || 0);
                    if (Math.abs(delta) > 0.05) audio.currentTime = enginePos;
                    audio.playbackRate = 1.0;
                    audio.play().catch(() => {});
                }
                mode = "AUTO";
                rampGain(nativeGain, 1, XFADE_MS);
                rampGain(djGain, 0, XFADE_MS);
                ignoreInputUntil = performance.now() + POST_HANDOFF_MUTE_MS;
                setBadge(mode, 1.0);
            }

            /* ===== Input / Unlock ===== */
            async function robustUnlock() {
                try {
                    if (ctx.state !== "running") await ctx.resume();
                } catch {}
                try {
                    await audio.play();
                } catch {}
            }
            function markUserControl(e) {
                const now = performance.now();
                if (now < ignoreInputUntil) return;
                if (now - bootTs < START_DEBOUNCE_MS) return;
                if (e && e.isTrusted === false) return;
                robustUnlock();
                lastUserTs = now;
                if (mode !== "USER" && mode !== "USER_HYBRID") enterUser();
            }
            [
                "wheel",
                "touchstart",
                "touchmove",
                "pointerdown",
                "keydown",
                "mousedown",
            ].forEach((evt) => {
                addEventListener(evt, markUserControl, { passive: true });
            });

            /* ===== Main loop (Hybrid with hysteresis) ===== */
            let lastT = performance.now(),
                lastY = scrollY;
            let promoteTick = 0,
                hybridArmTs = 0;
            function loop() {
                const now = performance.now(),
                    dt = Math.max(1, now - lastT),
                    dy = scrollY - lastY;
                lastT = now;
                lastY = scrollY;
                if (!mappingReady) {
                    requestAnimationFrame(loop);
                    return;
                }

                if (mode === "AUTO") {
                    if (audioReady && !audio.paused) {
                        const y = yFromTime(audio.currentTime, duration);
                        if (Math.abs(scrollY - y) > 0.5) scrollTo(0, y);
                        setBadge(mode, 1.0);
                    } else if (waReady) {
                        mode = "AUTO_SIM";
                        rampGain(djGain, 1, 140);
                        rampGain(nativeGain, 0, 140);
                        setBadge("AUTO", 1.0);
                    }
                } else if (mode === "AUTO_SIM") {
                    const y = yFromTime(
                        enginePos,
                        waBuf ? waBuf.duration : duration || 0
                    );
                    if (Math.abs(scrollY - y) > 0.5) scrollTo(0, y);
                    setBadge("AUTO", 1.0);
                    if (audioReady && ++promoteTick % 30 === 0) {
                        robustUnlock().then(() => {
                            if (!audio.paused) {
                                rampGain(nativeGain, 1, XFADE_MS);
                                rampGain(djGain, 0, XFADE_MS);
                                setTimeout(() => {
                                    mode = "AUTO";
                                }, XFADE_MS + 40);
                            }
                        });
                    }
                } else {
                    // USER / USER_HYBRID
                    const pxps = (dy * 1000) / dt;
                    const torque = pxps * DRAG_SENSITIVITY;
                    rateTarget += torque;
                    rateTarget += (1.0 - rateTarget) * RETURN_LAMBDA;
                    if (Math.abs(pxps) < 1.5)
                        rateTarget += (1.0 - rateTarget) * FRICTION_DECAY;
                    platterRate += (rateTarget - platterRate) * 0.25;
                    platterRate = clamp(platterRate, -RATE_CAP, RATE_CAP);

                    // Hybrid enter with dwell + hysteresis
                    const inEnter =
                        platterRate > 0 &&
                        platterRate >= HYBRID_ENTER_MIN &&
                        platterRate <= HYBRID_ENTER_MAX &&
                        Math.abs(pxps) < HYBRID_VEL_PXPS;
                    const inExit = !(
                        platterRate > 0 &&
                        platterRate >= HYBRID_EXIT_MIN &&
                        platterRate <= HYBRID_EXIT_MAX &&
                        Math.abs(pxps) < HYBRID_VEL_PXPS
                    );

                    if (mode === "USER" && inEnter) {
                        if (hybridArmTs === 0) hybridArmTs = now;
                        if (
                            now - hybridArmTs >= HYBRID_STICK_MS &&
                            audioReady
                        ) {
                            // blend to native
                            audio.playbackRate = clamp(platterRate, 0.8, 1.35);
                            // micro nudge native toward engine
                            const cur = audio.currentTime || 0,
                                tgt = enginePos,
                                nudge = clamp(tgt - cur, -0.04, 0.04);
                            audio.currentTime = clamp(
                                cur + nudge,
                                0,
                                duration || tgt
                            );
                            mode = "USER_HYBRID";
                            rampGain(nativeGain, 1, HYBRID_RAMP_MS);
                            rampGain(djGain, 0.12, HYBRID_RAMP_MS);
                        }
                    } else if (mode === "USER_HYBRID") {
                        if (inExit) {
                            // back to full DJ
                            audio.playbackRate = 1.0;
                            mode = "USER";
                            rampGain(djGain, 1, HYBRID_RAMP_MS);
                            rampGain(nativeGain, 0, HYBRID_RAMP_MS);
                            hybridArmTs = 0;
                        } else {
                            // stay hybrid: keep small nudge & follow rate
                            audio.playbackRate = clamp(platterRate, 0.8, 1.35);
                            const cur = audio.currentTime || 0,
                                tgt = enginePos,
                                nudge = clamp(tgt - cur, -0.025, 0.025);
                            audio.currentTime = clamp(
                                cur + nudge,
                                0,
                                duration || tgt
                            );
                        }
                    } else {
                        // not in enter window → disarm
                        hybridArmTs = 0;
                    }

                    setBadge(mode, platterRate);

                    // Calm → return to AUTO
                    const calm =
                        now - lastUserTs >= IDLE_BACK_MS &&
                        Math.abs(pxps) < 1.2 &&
                        Math.abs(platterRate - 1.0) < 0.1;
                    if (calm) exitUser();
                }

                requestAnimationFrame(loop);
            }
            requestAnimationFrame(loop);

            // initial layout
            recomputeMapping(false);
        </script>
    </body>
</html>
