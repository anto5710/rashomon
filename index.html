<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Scroll ⇄ Audio (Vinyl DJ + Solid Auto)</title>
<style>
  html,body{margin:0;background:#0f172a;color:#e5e7eb;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  .wrap{max-width:1200px;margin:0 auto;font-size:0;line-height:0}
  .wrap img{display:block;width:100%;height:auto;margin:0;border:0}
  .hud{position:fixed;left:0;right:0;top:0;display:grid;place-items:center;padding:12px;pointer-events:none;z-index:10}
  .card{pointer-events:auto;background:rgba(15,23,42,.65);backdrop-filter:blur(10px);border-radius:12px;padding:10px 14px;font-size:14px}
  .time{font-variant-numeric:tabular-nums;color:#a3e635}.note{color:#cbd5e1}.hint{color:#facc15}.err{color:#fca5a5}
</style>
</head>
<body>
<div class="hud">
  <div class="card">
    <div><b id="modeLbl">Auto (1×)</b> — scroll/touch/keys for vinyl DJ (↓ fwd, ↑ rev). Pause briefly to return to Auto.</div>
    <div><span id="now" class="time">00:00</span> / <span id="dur" class="time">00:00</span>
      <span id="rate" class="note" style="margin-left:8px;">1.00×</span>
      <span id="status" class="note" style="margin-left:8px;">Loading…</span>
      <span id="hint" class="hint" style="margin-left:8px;">If silent, tap once</span>
    </div>
  </div>
</div>

<div id="wrap" class="wrap" aria-label="Timeline images"></div>
<audio id="audio" src="track.mp3" preload="auto" playsinline muted autoplay></audio>

<script>
/* ===== CONFIG ===== */
const STRIP_COUNT=4, STRIP_PREFIX='strip', STRIP_EXT='png';
const START_DEBOUNCE_MS=400, IDLE_BACK_MS=900, POST_HANDOFF_MUTE_MS=700;
const HANDOFF_TOL=0.04, ALIGN_TOL_SEC=0.12, XFADE_MS=140;

const GRAIN_MS=40, HOP_MS=5, LOOKAHEAD_MS=60, ATTACK_MS=3, RELEASE_MS=3;
const PULL_ALPHA=0.06, RATE_CAP=2.5;
const DRAG_SENSITIVITY=1/800, RETURN_LAMBDA=0.18, FRICTION_DECAY=0.004;
const WOW_HZ=0.7, WOW_DEPTH=0.003, FLUT_HZ=6.0, FLUT_DEPTH=0.0005;

/* ===== STRIPS ===== */
const wrap=document.getElementById('wrap'), strips=[];
for(let i=0;i<=STRIP_COUNT;i++){const im=new Image();im.alt=`strip ${i}`;im.decoding='sync';im.loading='eager';im.src=`${STRIP_PREFIX}${i}.${STRIP_EXT}`;wrap.appendChild(im);strips.push(im);}
let mappingReady=false,startY=0,endY=1;
function recomputeMapping(lock=true){
  if(!strips.length)return;
  const p=(lock&&mappingReady)?(scrollY-startY)/(endY-startY):null;
  const first=strips[0], last=strips[strips.length-1];
  startY=first.offsetTop;
  endY=Math.max(startY+1, last.offsetTop+last.offsetHeight-innerHeight);
  mappingReady=true;
  if(p!=null&&isFinite(p)){const y=startY+Math.min(1,Math.max(0,p))*(endY-startY); if(Math.abs(scrollY-y)>0.5) scrollTo(0,y);}
}
addEventListener('resize',()=>recomputeMapping(true),{passive:true});
addEventListener('load',()=>{recomputeMapping(false); setTimeout(()=>recomputeMapping(true),200);},{once:true});
const yFromTime=(t,d)=>!mappingReady||!d?startY: startY+Math.min(1,Math.max(0,t/d))*(endY-startY);
const timeFromY=(y,d)=>!mappingReady||!d?0      : Math.min(d,Math.max(0,(y-startY)/(endY-startY)*d));

/* ===== HUD ===== */
const nowEl=document.getElementById('now'),durEl=document.getElementById('dur'),
      rateEl=document.getElementById('rate'),statusEl=document.getElementById('status'),
      hintEl=document.getElementById('hint'),modeLbl=document.getElementById('modeLbl');
const fmt=s=>{s=Math.max(0,s|0);const m=(s/60)|0,ss=(s%60)|0;return`${String(m).padStart(2,'0')}:${String(ss).padStart(2,'0')}`};
const clamp=(v,min,max)=>Math.min(Math.max(v,min),max);

/* ===== Native audio ===== */
const audio=document.getElementById('audio'); let audioReady=false,duration=0;
audio.addEventListener('loadedmetadata',()=>{
  audioReady=true; duration=audio.duration||0; durEl.textContent=fmt(duration|0);
  audio.play().then(()=>{statusEl.textContent='Auto (native)'; mode='AUTO';})
               .catch(()=>{statusEl.textContent='Auto (tap/scroll to start)';});
});
audio.addEventListener('playing',()=>{hintEl.style.display='none';});

/* ===== WebAudio ===== */
const ACtx=window.AudioContext||window.webkitAudioContext; const ctx=new ACtx({latencyHint:'interactive'});
const main=ctx.createGain(); main.connect(ctx.destination);
const nativeGain=ctx.createGain(), djGain=ctx.createGain(); nativeGain.gain.value=1; djGain.gain.value=0;
nativeGain.connect(main); djGain.connect(main);
const media=ctx.createMediaElementSource(audio); media.connect(nativeGain);

/* Vinyl LPF */
const djFilter=ctx.createBiquadFilter(); djFilter.type='lowpass'; djFilter.frequency.value=18000; djFilter.Q.value=.707; djFilter.connect(djGain);

/* Decode */
let waBuf=null, waBufRev=null, waReady=false;
function makeReversedBuffer(b){const r=ctx.createBuffer(b.numberOfChannels,b.length,b.sampleRate);
for(let c=0;c<b.numberOfChannels;c++){const s=b.getChannelData(c),d=r.getChannelData(c);for(let i=0,j=s.length-1;i<s.length;i++,j--) d[i]=s[j];}return r;}
(async()=>{try{const ab=await (await fetch('track.mp3',{cache:'no-store'})).arrayBuffer();
waBuf=await ctx.decodeAudioData(ab); waBufRev=makeReversedBuffer(waBuf); waReady=true;}catch(e){statusEl.innerHTML='<span class="err">Failed to decode track.mp3</span>';}})();

async function ensureUnlocked(){ try{await ctx.resume();}catch{} try{await audio.play();}catch{} audio.muted=false; }

/* ===== DJ scheduler ===== */
const grainSec=GRAIN_MS/1000, hopSec=HOP_MS/1000;
let scheduler=null,lastSch=0;
let enginePos=0, platterRate=1.0, rateTarget=1.0;
function startScheduler(){ if(scheduler) return; lastSch=ctx.currentTime;
  scheduler=setInterval(()=>{
    if(!waReady || (mode!=='USER' && mode!=='AUTO_SIM')) return;
    const now=ctx.currentTime, look=LOOKAHEAD_MS/1000;
    while(lastSch<now+look){
      const dir = platterRate>=0?+1:-1, buf = dir>=0?waBuf:waBufRev;
      const tMap=timeFromY(scrollY, waBuf.duration); if(mode==='USER') enginePos+=(tMap-enginePos)*PULL_ALPHA;

      const tAudio=now, wow=WOW_DEPTH*Math.sin(2*Math.PI*WOW_HZ*tAudio), fl=FLUT_DEPTH*Math.sin(2*Math.PI*FLUT_HZ*tAudio);
      const base=clamp(Math.abs(platterRate),0.4,RATE_CAP), eff=clamp(base*(1+wow+fl),0.3,RATE_CAP);
      djFilter.frequency.setTargetAtTime(16000/(1+Math.max(0,eff-1)*2), ctx.currentTime, 0.02);

      const offset=clamp(dir>=0?enginePos:(waBuf.duration-enginePos-grainSec),0,buf.duration-grainSec);
      const src=ctx.createBufferSource(); src.buffer=buf; src.playbackRate.value=eff;
      const g=ctx.createGain(); const startAt=lastSch+0.003,endAt=startAt+grainSec;
      const A=ATTACK_MS/1000,R=RELEASE_MS/1000;
      g.gain.setValueAtTime(0,startAt); g.gain.linearRampToValueAtTime(1,startAt+Math.min(A,grainSec*0.45));
      g.gain.setValueAtTime(1,endAt-Math.min(R,grainSec*0.45)); g.gain.linearRampToValueAtTime(0,endAt);
      src.connect(g); g.connect(djFilter); src.start(startAt,offset,grainSec); src.stop(endAt);

      enginePos=clamp(enginePos+(dir>=0?+1:-1)*hopSec*eff,0,waBuf.duration);
      lastSch=endAt;
    }
  }, Math.max(6, HOP_MS/2));
}
function stopScheduler(){ if(scheduler){clearInterval(scheduler); scheduler=null;} }

/* ===== Modes & handoff ===== */
let mode='AUTO'; let lastUserTs=performance.now(), ignoreInputUntil=0;
const bootTs=performance.now(); let handoff={pending:false,target:0};
function setModeLabel(){ modeLbl.textContent=(mode==='USER'?'You control':'Auto (1×)'); }
function rampGain(node,to,ms){const now=ctx.currentTime,t=ms/1000; node.gain.cancelScheduledValues(now); node.gain.setValueAtTime(node.gain.value,now); node.gain.linearRampToValueAtTime(to,now+t);}

function enterUser(){
  if(mode==='USER') return;
  if(waReady){const tVis=timeFromY(scrollY, waBuf.duration); enginePos=isFinite(tVis)?tVis:(audioReady?audio.currentTime:0);}
  platterRate=1.0; rateTarget=1.0;
  startScheduler(); mode='USER'; setModeLabel(); statusEl.textContent='DJ mode';
  audio.muted=true; rampGain(djGain,1,XFADE_MS); rampGain(nativeGain,0,XFADE_MS);
}
function exitUser(){
  if(mode!=='USER'||!audioReady) return;
  handoff.pending=true; handoff.target=enginePos;
  audio.muted=true; audio.play().catch(()=>{}); audio.currentTime=handoff.target;
}
audio.addEventListener('seeked',()=>{
  if(!handoff.pending) return;
  let last=audio.currentTime, ticks=0;
  const probe=()=>{const ct=audio.currentTime, near=Math.abs(ct-handoff.target)<=HANDOFF_TOL, adv=ct>last; last=ct;
    if(near&&adv)ticks++; if(ticks>=2){ audio.muted=false; rampGain(nativeGain,1,XFADE_MS); rampGain(djGain,0,XFADE_MS);
      setTimeout(()=>{ mode='AUTO'; setModeLabel(); statusEl.textContent='Auto (native)'; handoff.pending=false; ignoreInputUntil=performance.now()+POST_HANDOFF_MUTE_MS; }, XFADE_MS+40);
    } else requestAnimationFrame(probe); };
  requestAnimationFrame(probe);
});

/* ===== Inputs ===== */
function markUserControl(e){
  const now=performance.now();
  if(now<ignoreInputUntil) return;                         // ignore tiny inertia after handoff
  if(now-bootTs<START_DEBOUNCE_MS) return;                 // ignore startup phantom
  if(e && e.isTrusted===false) return;
  ensureUnlocked();
  lastUserTs=now;
  if(mode!=='USER') enterUser();
}
addEventListener('wheel',e=>markUserControl(e),{passive:true});
addEventListener('touchstart',e=>markUserControl(e),{passive:true});
addEventListener('touchmove',e=>markUserControl(e),{passive:true});
addEventListener('pointerdown',e=>markUserControl(e),{passive:true});
addEventListener('keydown',e=>{const k=['ArrowUp','ArrowDown','PageUp','PageDown','Home','End',' ','Spacebar']; if(k.includes(e.key)) markUserControl(e);},{passive:true});

/* ===== Loop ===== */
let lastT=performance.now(), lastY=scrollY;
let promoteTick=0;
function loop(){
  const now=performance.now(), dt=Math.max(1,now-lastT); const dy=scrollY-lastY; lastT=now; lastY=scrollY;

  if(!mappingReady){ requestAnimationFrame(loop); return; }

  if(mode==='AUTO'){
    if(audioReady && !audio.paused){
      const y=yFromTime(audio.currentTime,duration); if(Math.abs(scrollY-y)>0.5) scrollTo(0,y);
      nowEl.textContent=fmt(audio.currentTime|0); rateEl.textContent='1.00×'; statusEl.textContent='Auto (native)'; setModeLabel();
    }else if(waReady){
      // Bootstrap granular auto if native blocked
      if(mode!=='AUTO_SIM'){ mode='AUTO_SIM'; setModeLabel(); statusEl.textContent='Auto (granular bootstrap)'; startScheduler(); rampGain(djGain,1,120); rampGain(nativeGain,0,120); }
    }

  } else if(mode==='AUTO_SIM'){
    const y=yFromTime(enginePos, waBuf?waBuf.duration:duration||0); if(Math.abs(scrollY-y)>0.5) scrollTo(0,y);
    nowEl.textContent=fmt(enginePos|0); rateEl.textContent='1.00×';
    // Try promote every ~500ms
    if(audioReady && (++promoteTick%30===0)){ audio.play().then(()=>{ audio.muted=false; rampGain(nativeGain,1,XFADE_MS); rampGain(djGain,0,XFADE_MS);
      setTimeout(()=>{ mode='AUTO'; setModeLabel(); statusEl.textContent='Auto (native)'; }, XFADE_MS+40);
    }).catch(()=>{}); }

  } else if(mode==='USER'){
    // Platter physics from scroll
    const pxps=(dy*1000)/dt;
    const torque=pxps*DRAG_SENSITIVITY;
    rateTarget += torque;
    // return toward 1×
    rateTarget += (1.0 - rateTarget) * RETURN_LAMBDA;
    if(Math.abs(pxps)<2) rateTarget += (1.0 - rateTarget) * FRICTION_DECAY;
    platterRate += (rateTarget - platterRate) * 0.28;
    platterRate = clamp(platterRate, -RATE_CAP, RATE_CAP);
    rateEl.textContent=`${Math.abs(platterRate).toFixed(2)}×`;
    if(waReady) nowEl.textContent=fmt(enginePos|0);

    // Calm detector: low velocity, platter ~1×, alignment with timeline
    const lowVel=Math.abs(pxps)<1.5;
    const nearOne=Math.abs(platterRate-1.0)<0.06 && Math.abs(rateTarget-1.0)<0.08;
    let aligned=false; if(waReady){const tMap=timeFromY(scrollY, waBuf.duration); aligned=Math.abs(enginePos - tMap) <= ALIGN_TOL_SEC;}
    const idleEnough = (now - lastUserTs) >= IDLE_BACK_MS;
    if(idleEnough && lowVel && nearOne && aligned){ exitUser(); }
  }

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// Kick mapping once
recomputeMapping(false);
</script>
</body>
</html>
