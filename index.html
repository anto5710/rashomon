<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>↓</title>
<style>
  html,body{
    margin:0;
    background:#000000;
    color:#e5e7eb;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
  }
  .wrap{
    max-width:1200px;
    margin:0 auto;
    font-size:0;
    line-height:0;
    will-change:filter,transform;
    transition:transform 60ms linear;
    filter:url(#motionBlur);
  }
  .frame{
    position:relative;
    width:100%;
    background:#000000; /* fallback so you never see page bg */
  }
  .base{
    position:absolute; inset:0;
    display:block; width:100%; height:100%;
    object-fit:cover; margin:0; border:0;
  }

  .loading{
    position:fixed; inset:0; display:grid; place-items:center;
    background:#0b1020; z-index:9999; transition:opacity .35s ease;
  }
  .loading.hide{opacity:0; pointer-events:none}
  .dots{display:inline-flex; gap:6px; align-items:center; color:#cbd5e1; font-size:0;}
  .dot{width:8px; height:8px; border-radius:50%; background:currentColor; opacity:.25; animation:bounce 1.1s infinite ease-in-out}
  .dot:nth-child(2){animation-delay:.12s}
  .dot:nth-child(3){animation-delay:.24s}
  @keyframes bounce{0%,80%,100%{transform:translateY(0);opacity:.25}40%{transform:translateY(-6px);opacity:.95}}

  .hint{
    position:fixed; left:50%; bottom:20px; transform:translateX(-50%);
    z-index:10; font-size:14px; opacity:.9; user-select:none; pointer-events:none;
    animation:blink 1.1s ease-in-out infinite;
  }
  @keyframes blink{0%,100%{opacity:.15}50%{opacity:.95}}
  .hint.hide{animation:none; opacity:0; transition:opacity .35s ease}

  @media (max-width:600px){
    .hint{font-size:12px; bottom:16px}
    .dot{width:7px; height:7px}
    .dots{gap:5px}
  }
</style>
</head>
<body>
<!-- SVG directional blur -->
<svg width="0" height="0" style="position:absolute">
  <filter id="motionBlur" x="-50%" y="-50%" width="200%" height="200%">
    <feGaussianBlur in="SourceGraphic" stdDeviation="0 0"/>
  </filter>
</svg>

<div id="loader" class="loading" aria-live="polite" aria-label="Loading">
  <div class="dots" aria-hidden="true"><div class="dot"></div><div class="dot"></div><div class="dot"></div></div>
</div>

<div id="wrap" class="wrap" aria-label="Timeline images"></div>
<div id="hint" class="hint hide" aria-hidden="true">⬇︎</div>

<script>
/* ================== CONFIG ================== */
const STRIP_COUNT  = 354;
const STRIP_PREFIX = "strips/strip";
const STRIP_EXT    = "jpeg";
const USE_MOD      = true; // strip{ i % MOD_BASE }
const MOD_BASE     = 6;

const AUDIO_URL = "tracks/nymetro.mp3";

/* Audio engine params */
const XFADE_MS=260, GRAIN_MS=80, HOP_MS=5, LOOKAHEAD_MS=30, MICRO_JITTER_MS=0.25, RATE_CAP=2.0;
const DRAG_SENSITIVITY=1/980, RETURN_LAMBDA=0.12, FRICTION_DECAY=0.0038;
const WOW_HZ=0.6, WOW_DEPTH=0.0023, FLUT_HZ=5.5, FLUT_DEPTH=0.0004;
const LP_MIN=1500, LP_MAX=11000;
const IDLE_HOLD_MS=650, RATE_EPS=0.02;

/* Blur/visual feel */
const IS_TOUCH = matchMedia("(pointer: coarse)").matches;
/* faster decay on mobile, slightly faster overall */
const BLUR_TARGET_GAIN = IS_TOUCH ? 1.2 : 3.3;
const BLUR_MAX = 30;
const BLUR_THRESHOLD = IS_TOUCH ? 0.9 : 0.7;
const BLUR_SMOOTH_UP   = IS_TOUCH ? 0.35 : 1.4;  // how fast blur grows when speeding up
const BLUR_SMOOTH_DOWN = IS_TOUCH ? 1.95 : 1.2;  // how fast blur clears when slowing/stopping
const SHIFT_GAIN = 5, SHIFT_MAX = 6, SHIFT_SMOOTH = 0.6;

/* Prefetch strategy to avoid background reveal */
const PRELOAD_INITIAL = IS_TOUCH ? 180 : 12;   // load N frames at start
const PREFETCH_AHEAD  = IS_TOUCH ? 108 : 12;   // load this many ahead of viewport
const PREFETCH_BEHIND = IS_TOUCH ? 8  : 6;    // and behind
const OBS_ROOT_MARGIN = IS_TOUCH ? "2500px 0px" : "1800px 0px";

/* ================== DOM BUILD ================== */
const wrap = document.getElementById("wrap");
const frames = new Array(STRIP_COUNT + 1);
const bases  = new Array(STRIP_COUNT + 1);

for (let i = 0; i <= STRIP_COUNT; i++) {
  const frame = document.createElement("div");
  frame.className = "frame";
  frame.style.aspectRatio = "16 / 9"; // will be corrected after probe

  const base = new Image();
  base.className = "base"; // no src yet

  frame.appendChild(base);
  wrap.appendChild(frame);
  frames[i] = frame;
  bases[i]  = base;
}

/* ================== SIZE CALIBRATION ================== */
let mappingReady=false, startY=0, endY=1, duration=0;

async function calibrateAspect(){
  const probe = new Image();
  probe.decoding = "sync";
  probe.loading  = "eager";
  probe.src = baseSrc(0);
  try{ if (probe.decode) await probe.decode(); }catch{}
  const w = probe.naturalWidth || 1920;
  const h = probe.naturalHeight || 1080;
  const ratio = `${w} / ${h}`;
  frames.forEach(f => f.style.aspectRatio = ratio);

  // show top image quickly
  bases[0].src = probe.src;
  try{ if (bases[0].decode) await bases[0].decode(); }catch{}
}

function recomputeMapping(lock=true){
  const p = (lock && mappingReady) ? (scrollY - startY) / (endY - startY) : null;
  const first = frames[0];
  const last  = frames[frames.length - 1];
  startY = first.offsetTop;
  endY   = Math.max(startY + 1, last.offsetTop + last.offsetHeight - innerHeight);
  mappingReady = true;
  if (p != null && isFinite(p)) {
    const y = startY + Math.min(1, Math.max(0, p)) * (endY - startY);
    if (Math.abs(scrollY - y) > 0.5) scrollTo(0, y);
  }
}

addEventListener("resize", ()=>recomputeMapping(true), {passive:true});

function baseSrc(i){
  const idx = USE_MOD ? (i % MOD_BASE) : i;
  return `${STRIP_PREFIX}${idx}.${STRIP_EXT}`;
}

/* Load helpers */
async function ensureBaseLoaded(i){
  const img = bases[i];
  if (!img || img.getAttribute("src")) return;
  img.src = baseSrc(i);
  try{ if (img.decode) await img.decode(); }catch{}
}

/* Preload an initial burst at startup */
async function preloadInitial(){
  const end = Math.min(STRIP_COUNT, PRELOAD_INITIAL);
  const jobs = [];
  for (let i = 0; i <= end; i++) jobs.push(ensureBaseLoaded(i));
  await Promise.all(jobs);
}

/* Prefetch around a center index (no unload to avoid flicker) */
async function prefetchWindow(centerIdx){
  const from = Math.max(0, centerIdx - PREFETCH_BEHIND);
  const to   = Math.min(STRIP_COUNT, centerIdx + PREFETCH_AHEAD);
  for (let i = from; i <= to; i++) ensureBaseLoaded(i);
}

/* IO to detect visible frame and expand prefetch aggressively */
let lastVisibleIdx = 0;
const io = new IntersectionObserver((entries)=>{
  entries.forEach(entry=>{
    if (!entry.isIntersecting) return;
    const i = frames.indexOf(entry.target);
    if (i < 0) return;
    lastVisibleIdx = i;
    ensureBaseLoaded(i);
    // burst prefetch around the visible frame
    prefetchWindow(i);
  });
},{root:null, rootMargin: OBS_ROOT_MARGIN, threshold: 0.01});

frames.forEach(f => io.observe(f));

/* ================== AUDIO: SCROLL-DJ ENGINE ================== */
const ACtx = window.AudioContext || window.webkitAudioContext;
const ctx  = new ACtx({ latencyHint: "interactive" });
const main = ctx.createGain(); main.connect(ctx.destination);
const djGain = ctx.createGain(); djGain.gain.value = 0; djGain.connect(main);

const djLowShelf = ctx.createBiquadFilter(); djLowShelf.type="lowshelf"; djLowShelf.frequency.value=160; djLowShelf.gain.value=3.2;
const djHighShelf= ctx.createBiquadFilter(); djHighShelf.type="highshelf"; djHighShelf.frequency.value=5200; djHighShelf.gain.value=-2.0;
const djLP       = ctx.createBiquadFilter(); djLP.type="lowpass"; djLP.frequency.value=11000; djLP.Q.value=0.55;
const djComp     = ctx.createDynamicsCompressor(); djComp.threshold.value=-20; djComp.knee.value=10; djComp.ratio.value=2.2; djComp.attack.value=0.004; djComp.release.value=0.12;
const djMakeup   = ctx.createGain(); djMakeup.gain.value=1.24;
djLowShelf.connect(djHighShelf); djHighShelf.connect(djLP); djLP.connect(djComp); djComp.connect(djMakeup); djMakeup.connect(djGain);

function hannCurve(n){ const a=new Float32Array(n);
  for(let i=0;i<n;i++) a[i]=0.5-0.5*Math.cos((2*Math.PI*i)/(n-1));
  let p=0; for(let i=0;i<n;i++) p=Math.max(p,a[i]);
  for(let i=0;i<n;i++) a[i]/=p; return a; }
const ENV_SAMPLES=128, HANN_ENV=hannCurve(ENV_SAMPLES);

let buffer=null, bufferRev=null, waReady=false;
function makeReversed(b){
  const r=ctx.createBuffer(b.numberOfChannels,b.length,b.sampleRate);
  for(let c=0;c<b.numberOfChannels;c++){ const s=b.getChannelData(c), d=r.getChannelData(c);
    for(let i=0,j=s.length-1;i<s.length;i++,j--) d[i]=s[j]; }
  return r;
}
async function loadAudio(){
  const ab = await (await fetch(AUDIO_URL,{cache:"no-store"})).arrayBuffer();
  buffer    = await ctx.decodeAudioData(ab);
  bufferRev = makeReversed(buffer);
  duration  = buffer.duration || 0;
  waReady   = true;
}

/* ================== STARTUP ================== */
const loaderEl = document.getElementById("loader");
const hintEl   = document.getElementById("hint");

async function initLoad(){
  try{
    await calibrateAspect();
    await Promise.all([loadAudio(), preloadInitial()]);
    recomputeMapping(false);
    setTimeout(()=>recomputeMapping(true), 30);
    // kick a first prefetch window for safety
    prefetchWindow(0);

    loaderEl.classList.add("hide");
    hintEl.classList.remove("hide");
    startScheduler();
  }catch(e){
    console.error("Loading failed:", e);
    loaderEl.textContent = "Failed to load media.";
  }
}

addEventListener("load", ()=>{
  if ("scrollRestoration" in history) history.scrollRestoration = "manual";
  scrollTo(0,0);
  initLoad();
},{once:true});

/* ================== ENGINE / SCHEDULER ================== */
const grainSec=GRAIN_MS/1000, hopSec=HOP_MS/1000, jitterMax=MICRO_JITTER_MS/1000;
let scheduler=null, lastSch=0;
let enginePos=0, platterRate=0.0, rateTarget=0.0, lastUserTs=0;

const clamp=(v,a,b)=>Math.min(Math.max(v,a),b);
function ramp(node,to,ms){ const n=ctx.currentTime, t=Math.max(0.001, ms/1000);
  node.gain.cancelScheduledValues(n); node.gain.setValueAtTime(node.gain.value,n);
  node.gain.linearRampToValueAtTime(to,n+t); }

function scheduleGrain(buf, startClock, offset, rate){
  const src=ctx.createBufferSource(); src.buffer=buf; src.playbackRate.value=rate;
  const g=ctx.createGain(); g.gain.setValueCurveAtTime(HANN_ENV,startClock,grainSec);
  src.connect(g); g.connect(djLowShelf);
  src.start(startClock,offset,grainSec); src.stop(startClock+grainSec);
}

function startScheduler(){
  if (scheduler || !waReady) return;
  lastSch = ctx.currentTime;
  scheduler = setInterval(()=>{
    if (!waReady || !mappingReady) return;
    const now = ctx.currentTime, look = LOOKAHEAD_MS/1000;
    while(lastSch < now + look){
      const active = (performance.now()-lastUserTs) < IDLE_HOLD_MS || Math.abs(platterRate) > RATE_EPS;
      if(!active){
        djLP.frequency.setTargetAtTime(1900, ctx.currentTime, 0.05);
        djHighShelf.gain.setTargetAtTime(-7.0, ctx.currentTime, 0.05);
        ramp(djGain, 0, XFADE_MS);
        lastSch += hopSec; continue;
      }

      const dir = platterRate>=0 ? +1 : -1;
      const buf = dir>=0 ? buffer : bufferRev;

      const tAudio=lastSch;
      const wow=WOW_DEPTH*Math.sin(2*Math.PI*WOW_HZ*tAudio);
      const fl =FLUT_DEPTH*Math.sin(2*Math.PI*FLUT_HZ*tAudio);
      const base=clamp(Math.abs(platterRate),0.45,RATE_CAP);
      const eff =clamp(base*(1+wow+fl),0.38,RATE_CAP);

      const tMap = timeFromY(scrollY, duration);
      enginePos += (tMap - enginePos) * 0.12;

      const tail=0.006;
      let off = dir>=0 ? enginePos : (duration - enginePos - grainSec);
      off = clamp(off, 0, buf.duration - grainSec - tail);

      ramp(djGain, 1, XFADE_MS);

      const startAt = lastSch + 0.002 + ((Math.random()*2-1)*jitterMax);
      scheduleGrain(buf, startAt, off, eff);
      const startAt2 = startAt + hopSec/2;
      const off2 = clamp(off + (dir>=0?+1:-1)*(hopSec/2)*eff, 0, buf.duration - grainSec - tail);
      scheduleGrain(buf, startAt2, off2, eff);

      enginePos = clamp(enginePos + (dir>=0?+1:-1)*hopSec*eff, 0, duration);
      lastSch = startAt + hopSec;
    }
  }, Math.max(5, HOP_MS/2));
}

/* ================== INPUT & VISUALS ================== */
const feBlur = document.querySelector("#motionBlur feGaussianBlur");
let blurYVis=0, shiftVis=0, hintAutofaded=false;

async function unlock(){ try{ if(ctx.state!=="running") await ctx.resume(); }catch{} }
function onUser(e){
  if (e && e.isTrusted===false) return;
  unlock();
  lastUserTs = performance.now();
}
["wheel","touchstart","touchmove","pointerdown","keydown","mousedown"].forEach(evt=>{
  addEventListener(evt, onUser, {passive:true});
});

function timeFromY(y, d){
  if(!mappingReady || !d) return 0;
  return Math.min(d, Math.max(0, ((y - startY) / (endY - startY)) * d));
}

addEventListener("scroll", ()=>{
  // when user scrolls, ensure an extra prefetch wave centered at lastVisibleIdx
  prefetchWindow(lastVisibleIdx);
}, {passive:true});

let lastT=performance.now(), lastY=scrollY;
function loop(){
  const now=performance.now(), dt=Math.max(1, now-lastT), dy=scrollY-lastY;
  lastT=now; lastY=scrollY;

  if(mappingReady){
    if(!hintAutofaded && !hintEl.classList.contains("hide") && Math.abs(dy)>2){
      hintEl.classList.add("hide"); hintAutofaded=true;
    }

    const pxps=(dy*1000)/dt, torque=pxps*DRAG_SENSITIVITY;
    rateTarget += torque;
    if(Math.abs(pxps)<1.5) rateTarget += (0 - rateTarget) * RETURN_LAMBDA;
    rateTarget += (0 - rateTarget) * FRICTION_DECAY;

    platterRate += (rateTarget - platterRate) * 0.25;
    platterRate = clamp(platterRate, -RATE_CAP, RATE_CAP);

    // Directional blur with asymmetric smoothing (faster decay on stop, esp. mobile)
    const speed = platterRate, absSpeed = Math.abs(speed);
    let blurTarget = Math.max(0, (absSpeed - BLUR_THRESHOLD) * BLUR_TARGET_GAIN);
    blurTarget = Math.min(BLUR_MAX, blurTarget);
    const k = (blurTarget < blurYVis) ? BLUR_SMOOTH_DOWN : BLUR_SMOOTH_UP;
    blurYVis = blurYVis + (blurTarget - blurYVis) * k;
    feBlur.setAttribute("stdDeviation", `0 ${blurYVis.toFixed(2)}`);

    // slight directional nudge
    const shiftTarget = Math.sign(speed) * Math.min(SHIFT_MAX, absSpeed * SHIFT_GAIN);
    shiftVis = shiftVis + (shiftTarget - shiftVis) * SHIFT_SMOOTH;
    wrap.style.transform = `translateY(${shiftVis.toFixed(1)}px)`;
  }

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
